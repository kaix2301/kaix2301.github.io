[{"title":"GitHub+PicGo配置图床","url":"/2022/01/02/GitHub-PicGo%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A/","content":"点击上面的 “图床” tag，可以找到typora “自动化使用本文图床” 的配置方式\n1.Github建库和配置1-1.建库\n\n1-2.生成 token 备用，用于访问依次点击：头像—Settings—Developer settings—Personal access tokens—Generate new token\n\n\n\n\n生成后会有一段token序列号，一定！！！复制下来记录好，以后进入将看不到此序列，留着备用。\n2.PicGo 安装和配置2-1.PicGo下载安装点此PicGo下载进入下载页面，在2.3.0(目前最新版本)下找到安装包，进行安装\n\n\n2-1.PicGo配置\n\n\n自定义域名：\nhttps://cdn.jsdelivr.net/gh/用户名/库名\n\n\n\n3.使用上图左侧“上传区”里，可以直接上传，上传后自动复制链接\n上图左侧“相册”里，可以对已上传图片进行删除、复制链接等\n","categories":["图床"],"tags":["hexo","图床"]},{"title":"GoogleColab中常用Linux命令","url":"/2022/05/18/GoogleColab%E4%B8%AD%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/","content":"Google Colab的使用类似于 Jupyter Notebook，区别是可以使用官方提供的GPU，无需自行配置\nlsls -lpwdmkdir &lt;dirname&gt;cd &lt;dirname&gt;gdown # download files from google drivewget # download files from the internetpython &lt;python_file&gt; # Executes a python file\n\n","categories":["机器学习","工具"],"tags":["机器学习","Google Colab"]},{"title":"IDEA2018.3.6激活到2100年","url":"/2022/01/29/IDEA2018-3-6%E6%BF%80%E6%B4%BB%E5%88%B02100%E5%B9%B4/","content":"\n本文仅限于学习交流，请支持正版。\n\n1.下载安装包官网：https://www.jetbrains.com/idea/download/other.html\n\n下载好直接傻瓜式安装，不停下一步就好，需要选择的就是“安装路径”和“64位”。（记下安装路径，后面用）\n2.下载激活jar包链接： https://pan.baidu.com/s/1YhwaNrCssQKWfAIydiJRbg提取码：xrz1\n3.激活IDEA3-1.复制jar包将上一步下载的jar包，复制到idea安装路径的bin目录下。\n3-2.修改文件bin目录下idea.exe.vmoptions和idea64.exe.vmoptions两个文件。\n\n在两个文件结尾处，都加以下代码：\n-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2018.3.6\\bin\\JetbrainsIdesCrack-4.2-release-sha1-3323d5d0b82e716609808090d3dc7cb3198b8c4b.jar\n\n上面代码：-javaagent: + 刚刚的jar包的绝对路径\n3-3.输入激活码。打开IDEA后出现激活窗口，若没出现，点击“Help→Register”可以打开。\n点击窗口上Activation code，然后在下面输入激活码即可。\n\n激活码（代码块右上角一键复制）：\neyJsaWNlbnNlSWQiOiIyOUxSTk9FMVlLIiwibGljZW5zZWVOYW1lIjoi08C+w7ykPz9pZGVhLmZ4dy5sYSIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDIwLTA2LTE0In0seyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMjAtMDYtMTQifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMjAtMDYtMTQifSx7ImNvZGUiOiJSU0MiLCJwYWlkVXBUbyI6IjIwMjAtMDYtMTQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAyMC0wNi0xNCJ9LHsiY29kZSI6IlJTRiIsInBhaWRVcFRvIjoiMjAyMC0wNi0xNCJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDIwLTA2LTE0In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMjAtMDYtMTQifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAyMC0wNi0xNCJ9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAyMC0wNi0xNCJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDIwLTA2LTE0In0seyJjb2RlIjoiUkQiLCJwYWlkVXBUbyI6IjIwMjAtMDYtMTQifSx7ImNvZGUiOiJQQyIsInBhaWRVcFRvIjoiMjAyMC0wNi0xNCJ9LHsiY29kZSI6IlJTViIsInBhaWRVcFRvIjoiMjAyMC0wNi0xNCJ9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMC0wNi0xNCJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDIwLTA2LTE0In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMjAtMDYtMTQifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAyMC0wNi0xNCJ9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDIwLTA2LTE0In0seyJjb2RlIjoiUERCIiwicGFpZFVwVG8iOiIyMDIwLTA2LTE0In0seyJjb2RlIjoiUFdTIiwicGFpZFVwVG8iOiIyMDIwLTA2LTE0In0seyJjb2RlIjoiUEdPIiwicGFpZFVwVG8iOiIyMDIwLTA2LTE0In0seyJjb2RlIjoiUFBTIiwicGFpZFVwVG8iOiIyMDIwLTA2LTE0In0seyJjb2RlIjoiUFBDIiwicGFpZFVwVG8iOiIyMDIwLTA2LTE0In0seyJjb2RlIjoiUFJCIiwicGFpZFVwVG8iOiIyMDIwLTA2LTE0In0seyJjb2RlIjoiUFNXIiwicGFpZFVwVG8iOiIyMDIwLTA2LTE0In0seyJjb2RlIjoiRFAiLCJwYWlkVXBUbyI6IjIwMjAtMDYtMTQifSx7ImNvZGUiOiJSUyIsInBhaWRVcFRvIjoiMjAyMC0wNi0xNCJ9LHsiY29kZSI6IkRQQSIsInBhaWRVcFRvIjoiMjAyMC0wNi0xNCJ9XSwiaGFzaCI6IjE4MDUwOTkxLzA6LTE0Mzk5NjcyODAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=\n\n4.检查结果打开IDEA时，过渡页面下方显示2100，说明激活成功。\n\n","categories":["工具","激活"],"tags":["IDEA"]},{"title":"SpringBoot2.X常用注解","url":"/2022/01/30/SpringBoot2-X%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/","content":"@SpringBootApplication⽤于标记是SringBoot应⽤，⾥⾯包含多个⼦注解。\n@SpringBootApplication = @Configuration + @EnableAutoConfiguration + @ComponentScan\n\n\n@Configuration: 一般标注在某个类上，用于spring扫描注入,⼀般结合@Bean使\n@EnableAutoConfiguration: 启用Spring的自动加载配置,自动载⼊应用程序所需的所有Bean\n@ComponentScan：告诉spring扫描包的范围，默认是Applocation类所在的全部⼦包，可以指定 其他包 @ComponentScan({“net.xdclass.package1”,”net.xdclass.package2”})\n\n@Controller⽤于标记这个类是控制器，返回页面时使用。\n@ResponseBody控制器注释使用@Controller时，如果要返回JSON,则需要在接口上使用@ResponseBody才可以。\n@RestController标记这个类是⼀个控制器（同@Controller）。\n接⼝返回数据会序列化为JSON（同@ResponseBody）。\n@RequestMapping路由映射，用于类上做1级路径；用于某个接口上做子路径。\n@RequestMapping(&quot;api/v1/pri/absence_apply&quot;)\n\n@GetMapping，@PostMapping用于接口上做子路径，功能在@RequestMapping上增加了post和get的限制。\n","categories":["Java","SpringBoot"],"tags":["SpringBoot"]},{"title":"Hello World","url":"/2022/01/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"hexo + github 搭建博客","url":"/2022/01/01/hexo-github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","content":"流程：搭建本地博客—创建远程仓库—本地远程连接—本地发布到远程\n1.前提准备1.安装 git2.安装 node.js3.注册 GitHub 账号（用户名用英文）\n前两项都是傻瓜式安装，不停下一步。由于我很早就安装好并注册过了，没办法一步一步截图，所以这里不再赘述了。网上详细的教程很多，不难。\n2.搭建本地博客2-1.创建一个文件夹在任意位置创建一个文件夹，博客相关所有内容将全部再次文件夹中，我本人是 E:\\blog\\Hexo\n2-2.安装Hexo1.进入上面的文件夹\n2.鼠标右键，点击 Git Bash Here 进入执行命令的窗口\n3.执行安装命令 npm install hexo-cli -g\n4.执行初始化命令  hexo init， 等待执行完成后，文件夹中出现一些文件，说明安装成功，例如：\n\n\n5.执行生成命令 hexo g，再执行启动服务命令 hexo s。\n6.若输出 Hexo is running at http://localhost:4000 说明启动成功\n7.在浏览器中访问 http://localhost:4000查看博客效果，当然现在比较简陋\n6.进入执行命令的窗口，点击Ctrl+C可结束服务，继续执行其他命令\n3.创建远程仓库1.登录GitHub，点击图中位置，进入仓库页面\n\n\n2.点击如图位置，新建仓库\n\n\n3.新建仓库是信息填写细节要求如图，填好后点击确定创建\n\n\n4.本地远程连接4-1.绑定 SSH KEY1.本地生成 ssh key\n回到刚刚的执行命令的窗口，执行\nssh-keygen -t rsa -C &quot;your email@example.com&quot;\n\n使用 GitHub 绑定的邮箱\n不断回车，直到输出以下内容：\n\n\n按照该路径找到该文件，记事本打开，全选复制\n2.GitHub 绑定该ssh\n依次点击：头像—Settings—SSH and GPG keys—new ssh key\n\n\n执行命令窗口，执行  ssh -T git@github.com，回车后输入yes\n若输出 Hi ***! You&#39;ve successfully......说明绑定成功\n3.配置个人信息\ngit config --global user.name &quot;Github用户名&quot;git config --global user.email &quot;Github绑定的邮箱&quot;\n\n4-2.生成token1.依次点击：头像—Settings—Developer settings—Personal access tokens—Generate new token\n\n\n\n\n2.生成后会有一段token序列号，一定！！！复制下来记录好，以后进入将看不到此序列，留着备用。\n5.本地发布到远程5-1.绑定仓库路径1.进入自己创建的仓库，复制下来仓库路径\n\n\n2.博客配置文件中进行配置\n记事本（Notepad++、Vs Code等更好）打开 E:\\blog\\Hexo\\ _config.yml（换成自己的）\n将该文件靠后位置的：\ndeploy:  type: \n\n修改为\ndeploy:  type: git  repository: https://github.com/xxx/xxx.github.io.git  branch: main\n\n注意：必须是英文冒号；冒号后面都有一个空格；repository后面是刚刚复制的仓库路径\n5-2.本地博客发布到远程1.安装 hexo-deployer-git 自动部署发布工具\n在执行命令窗口执行 \nnpm install hexo-deployer-git --save\n\n2.发布\n依次执行：\n清除缓存 hexo clean ，生成 hexo g ，发布 hexo d\n3.错误处理\n若出现以下错误，有两种可能，点此查看解决方法，很简单。\nfatal: unable to access &#x27;https://github.com/*/*.github.io.git/&#x27;: Failed to connect to github.com port 443: Timed outFATAL &#123;  err: Error: Spawn failed      at ChildProcess.&lt;anonymous&gt; (E:\\blog\\Hexo\\node_modules\\hexo-util\\lib\\spawn.js:51:21)      at ChildProcess.emit (events.js:315:20)      at ChildProcess.cp.emit (E:\\blog\\Hexo\\node_modules\\cross-spawn\\lib\\enoent.js:34:29)      at Process.ChildProcess._handle.onexit (internal/child_process.js:276:12) &#123;    code: 128  &#125;&#125; Something&#x27;s wrong. \n\n4.没错误的话会弹出一个输入框，输入前面记录好的token序列确定后会成功发布\n6.检查在浏览器访问 https://用户名.github.io/，可看到远程博客效果，博客已经搭建成功。\n点击标题下 hexo 标签，可查看包括博客美化等相关文章\n","categories":["hexo","搭建"],"tags":["hexo"]},{"title":"hexo+github强制使用https","url":"/2022/01/04/hexo-github%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8https/","content":"建站和美化汇总问题如果绑定了自己的域名，访问者默认通过http方式访问\n\n搜索引擎更喜欢收录https的网站，不喜欢http\nhttps更安全，而且使用http访问时网址前会显示本站不安全\n使用不蒜子统计访问量时，同一用户多次刷新时，访问人数和总访问量都增加。使用https后，上述情况访问人数不再错误增加，访问量继续增加\n\n配置进入github.io仓库，点击settings，再点击左侧pages\n\n","categories":["hexo","搭建"],"tags":["hexo"]},{"title":"hexo-keep首页样式自定义","url":"/2022/01/08/hexo-keep%E9%A6%96%E9%A1%B5%E6%A0%B7%E5%BC%8F%E8%87%AA%E5%AE%9A%E4%B9%89/","content":"建站和美化汇总注：本文仅限于keep主题\n0.说明红框圈起来的部分是本文要改编的地方。\n配置文件中可以直接配置的不谈。\n首页原始效果：\n\n修改后：\n\n首页下文章列表原始效果：\n由于5和6都是白色背景，看起来只有文章列表\n\n修改后：\n\n1.一号框半透明目标：设置半透明，因为后面想改背景，半透明好看一点。\n打开文件Hexo\\themes\\keep\\source\\css\\layout\\_partial\\header.styl\n在其中找到下面代码：\n.header-wrapper &#123;  width: 100%;  height: 100%;  box-sizing: border-box;  display: flex;  align-items: center;  justify-content: center;  background: var(--background-color);  padding-top: $scroll-progress-bar-height;  ......\n\n修改background的值即可。\n比如background: rgba(255,255,255,0.9)，白色，不透明度0.9。\n2.二号框背景配置文件中可以直接改的缺点：\n\n改了之后原来的飘浮色块会消失\n新背景的范围不包括一号框位置\n\n直接修改源文件css样式：\n打开文件Hexo\\themes\\keep\\source\\css\\layout\\page.styl\n找到以下代码：\n.page-container &#123;  position: relative;  box-sizing: border-box;  width: 100%;  height: auto;    background: var(--background-color);  ......\n\n修改为：\n.page-container &#123;  position: relative;  box-sizing: border-box;  width: 100%;  height: auto;    /*背景图片路径*/  background: url(&quot;https://cdn.jsdelivr.net/gh/kaix2301/pictures/img202201081000420.jpg&quot;);  /*背景图片不重复多次显示*/  background-repeat: no-repeat;  /*窗口放缩时背景图片中心始终在屏幕中心*/  background-position: center;  /*背景图片固定，不滚动*/  background-attachment: fixed;  /*图片大小自适应窗口大小*/  background-size: cover ;  ......\n\n修改和增加的代码上面做了说明，可自行修改和取舍。\n3.三号框样式背景更换很可能导致原来的文字看不清楚，可修改文字样式。\n打开文件Hexo\\themes\\keep\\source\\css\\layout\\_partial\\first-screen.styl\n找到以下代码：\n.description &#123;      font-weight: bold;      font-size: $first-screen-font-size;      line-height: 1.8;      text-align: center;      color: var(--default-text-color);      +keep-tablet() &#123;        font-size: $first-screen-font-size * 0.9;      &#125;&#125;\n\n修改为：\n.description &#123;\t  background: rgba(50,50,50,0.4); /*字体背景颜色和透明的*/\t  padding: 5px 20px; /*字体背景框的大小*/\t  border-radius: 5px; /*圆角*/      font-weight: bold;      font-size: $first-screen-font-size;      line-height: 1.8;      text-align: center;      color: rgb(230,230,230); /*字体颜色*/      +keep-tablet() &#123;        font-size: $first-screen-font-size * 0.9;      &#125;&#125;\n\n修改和增加的代码上面做了说明，可自行修改和取舍。\n4.四号框样式目前还没改，不过改的话可以在下面位置改。\n打开文件Hexo\\themes\\keep\\source\\css\\layout\\_partial\\first-screen.styl\n找到以下代码：\n.s-icon-list &#123;      position: absolute;      bottom: 0;      font-size: $first-screen-icon-size;      text-align: center;      +keep-tablet() &#123;        font-size: $first-screen-icon-size * 0.9;      &#125;      .s-icon-item &#123;        margin-right: 20px;        cursor: pointer;        line-height: 2;        &amp;:last-child &#123;          margin-right: 0;        &#125;      &#125;&#125;\n\n5.五号框背景在有文字内容的页面设一个简洁背景，好看但不影响阅读。\n打开文件Hexo\\themes\\keep\\source\\css\\layout\\page.styl\n找到以下代码：\n.page-main-content &#123;    padding-top: $header-height;    position: relative;\t    .header-shrink &amp; &#123;    ......\n\n增加四条代码，修改为：\n.page-main-content &#123;\tpadding-top: $header-height;\tposition: relative;    \t/*背景图片路径*/\tbackground: url(&quot;https://cdn.jsdelivr.net/gh/kaix2301/pictures/img202201072225073.png&quot;);\t/*背景图片不重复多次显示*/\tbackground-repeat: no-repeat;\t/*窗口放缩时背景图片中心始终在屏幕中心*/\tbackground-position: center;\t/*背景图片固定，不滚动*/\tbackground-attachment: fixed;\t/*图片大小自适应窗口大小*/\tbackground-size: cover ;\t.header-shrink &amp; &#123;\t......\n\n修改和增加的代码上面做了说明，可自行修改和取舍。\n设置完此背景，除首页第一个背景外，其他页面都为此背景。\n6.六号框全透明此位置默认为白色背景，改为全透明。\n打开文件Hexo\\themes\\keep\\source\\css\\layout\\home-content.styl\n在开始位置找到以下代码：\n.home-content-container &#123;  background: var(--background-color);  ......\n\n修改为：\n.home-content-container &#123;  background: rgba(255,255,255,0);  ......\n\n7.七号框半透明此位置默认为白色背景，改为半透明。\n打开文件Hexo\\themes\\keep\\source\\css\\layout\\home-content.styl\n在开始位置找到以下代码：\n.home-article-item &#123;      position: relative;      keep-container(true, 1.015, 1.015, 28px, 38px);\t        .top-icon &#123;        position: absolute;        top: 10px;  ......\n\n加一条，修改为：\n.home-article-item &#123;      position: relative;      keep-container(true, 1.015, 1.015, 28px, 38px);\t  \t  background: rgba(255,255,255,0.8);/*白色半透明*/\t        .top-icon &#123;        position: absolute;        top: 10px;  ......\n\n","categories":["hexo","美化"],"tags":["hexo"]},{"title":"hexo 文章加密","url":"/2022/01/09/hexo-%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/","content":"1.安装encryptnpm install hexo-blog-encrypt\n\n2.配置参考Github上的官方文档，很详细。\nhttps://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md\n","categories":["hexo","美化"],"tags":["hexo"]},{"title":"hexo主题魔改汇总和总结","url":"/2022/01/09/hexo%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9%E6%B1%87%E6%80%BB%E5%92%8C%E6%80%BB%E7%BB%93/","content":"1.总结1-1.keep主题优点\n功能十分精简但好用，对我个人来所，用得到的功能，基本都内置了，直接配置即可，很方便。\n文档十分详细，每项都有解释，每个值的效果都截图展示，堪称完美。\n我个人并不喜欢把各种各样花哨的功能都堆上来。\n\n1-2.keep主题缺点\n样式单一，基本所有用户都是一模一样的，所以我对样式进行了许多改动。虽然本主题注重精简，但我觉得，多两个不同风格的简洁的主题也不错。\n\n1-3.安装并美化过程装博客、装主题和配置主题都很快，网上教程很多，keep主题文档也是非常好。\n接下来就是美化了，我喜欢的风格应该是”以简洁为基础，加上细节上的点缀“，不要浮夸臃肿。\n在美化上花的时间相对更多，毕竟网上关于此主题的美化教程一篇也没有 ¯_(ツ)_/¯ ！\n参考了其他主题的美化教程，加上自己看看源代码，改成了现在这样。\n1-4.本站缺陷博客和图床都在GitHub上，加载有时比较慢，图片相对更明显一点。\n2.建站和配置主题hexo + github 搭建博客\nhexo安装和配置主题\nGithub Page 强制使用 https \nhexo 文章加密\n3.美化汇总\n很多效果在官方文档中有说，这里不讲了\n\n3-1.hexo-keep背景和首页透明度 各页背景图片设置，首页文章列表透明度设置，顶部导航栏的透明度设置。\n3-2.hexo各页面白色模块半透明化如果设置了背景图片，可以调节各页白色背景的透明度。但建议有文字内容的部分不要太透明，毕竟看清内容才是第一需求。\n3-3.hexo顶部底部透明度渐变 初始状态顶部为白色方块，底部纯文字无白色。白方块个人觉得边界太明显，有点点突兀。没白色背景的话文字阅读会受背景图片干扰。因此设置为渐变了。\n3-4.hexo飘雪飘落叶特效 之前看到过别人博客飘樱花的效果。由于选择了秋天树下的背景，所以想搞一个飘落叶的效果。\n原始代码是参考别人的，我改了飘浮图片，改了飘浮密度，文章中都有讲。半透明图片是我自己用ps处理的。\n3-5.hexo自定义鼠标指针样式 细心的小伙伴可能已经发现在本站中鼠标箭头和其他地方不一样。仍然不喜欢太浮夸的，所以选择了比较普通但有点可爱的风格。\n3-6.hexo点击效果鼠标点击时可以增加效果，文中写了彩色爱心和社会主义核心价值观两种效果。\n","categories":["hexo","美化"],"tags":["hexo"]},{"title":"hexo博客-主题和美化","url":"/2022/01/02/hexo%E5%8D%9A%E5%AE%A2-%E4%B8%BB%E9%A2%98%E5%92%8C%E7%BE%8E%E5%8C%96/","content":"建站和美化汇总以此博客为例，使用 keep 主题，效果可看到\n选择此主题原因：\n\n不喜欢很炫酷很花哨的风格，此主题简洁大方\n当前效果中，所有看得到的都可以直接配置，不复杂\n本站目前只用于学习记录和笔记整理，不追求推广什么的，故不开评论\n\n下载安装主题1.进入博客文件夹，右键打开 Git Bash\n2.克隆仓库\ngit clone https://github.com/XPoet/hexo-theme-keep themes/keep\n\n注：官方文档还有一种npm install的安装方式，不建议\n3.编辑 博客文件夹\\_config.yml \n在靠后位置找到 theme, 将值更改为 keep\ntheme: keep\n\n配置主题编辑 博客文件夹\\themes\\keep\\_config.yml\n可直接参考官方文档，是我见过最好的说明文档\n对每个属性的每个值进行了解释，不同值对应的不同效果都有截图说明\n评论等功能在文档中也有详细教程\n注意：配置文件中所有冒号必须是英文的，冒号后必须有一个空格\n","categories":["hexo","搭建"],"tags":["hexo"]},{"title":"hexo各页面白色模块半透明化","url":"/2022/01/08/hexo%E5%90%84%E9%A1%B5%E9%9D%A2%E7%99%BD%E8%89%B2%E6%A8%A1%E5%9D%97%E5%8D%8A%E9%80%8F%E6%98%8E%E5%8C%96/","content":"建站和美化汇总1.首页上方导航栏，下面文章列表等，在中已讲明。\n2.文章阅读页面目标：文章背景和目录栏设置一定透明度\n\n2-1.文章背景打开文件Hexo\\themes\\keep\\source\\css\\layout\\article-content.styl\n开始位置有如下代码：\n.article-content-container &#123;  keep-container(false, 0, 0, 30px, 30px);    .article-title &#123;    color: var(--second-text-color);    font-weight: 600;    ......\n\n加一条，改为：\n.article-content-container &#123;  keep-container(false, 0, 0, 30px, 30px);  background: rgba(255,255,255,0.9);    .article-title &#123;    color: var(--second-text-color);    font-weight: 600;    ......\n\n2-2.左侧目录打开文件Hexo\\themes\\keep\\source\\css\\layout\\page.styl\n在较后位置找到以下代码：\n.page-aside &#123;    position: fixed;    top: 0;    bottom: 0;    left: - $page-aside-width;    width: $page-aside-width;    height: 100%;    z-index: $z-index-6;    overflow-y: auto;    padding: 20px;    box-sizing: border-box;\t    background: var(--background-color);\t......\n\nbackground的值改为：rgb（2-1中文章背景颜色）\nbackground下加一条font-weight: bold;使目录文字加粗。\n3.归档页面目标：下图列表背景设置一定透明度。\n\n打开文件Hexo\\themes\\keep\\source\\css\\layout\\archive-content.styl\n里面有：\n.archive-container &#123;  keep-container(false, 0, 0, 30px, 30px);&#125;\n\n修改为：\n.archive-container &#123;  keep-container(false, 0, 0, 30px, 30px);  background: rgba(255,255,255,0.9);&#125;\n\n4.分类页面目标：分类列表背景设置一定透明度。\n图示与”3.归档页面“类似。\n打开文件Hexo\\themes\\keep\\source\\css\\layout\\category-list.styl\n在开始位置有：\n.category-list-container &#123;  keep-container(false, 0, 0, 30px, 0);  .category-list-content &#123;    .all-category-list &#123;      li.all-category-list-item &#123;\t.......\n\n加一条，修改为：\n.category-list-container &#123;  keep-container(false, 0, 0, 30px, 0);  background: rgba(255,255,255,0.9);  .category-list-content &#123;    .all-category-list &#123;      li.all-category-list-item &#123;\t.......\n\n5.标签页面目标：标签云背景设置一定透明度。\n图示与”3.归档页面“类似。\n打开文件Hexo\\themes\\keep\\source\\css\\layout\\_partial\\tagcloud.styl\n在开始位置有：\n.tagcloud-container &#123;  keep-container(false, 0, 0, 20px, 0);  .tagcloud-content &#123;\t.......\n\n加一条，修改为：\n.tagcloud-container &#123;  keep-container(false, 0, 0, 20px, 0);  background: rgba(255,255,255,0.9);  .tagcloud-content &#123;\t.......\n\n6.关于页面目标：关于中文字背景设置一定透明度。\n图示与”3.归档页面“类似。\n打开文件Hexo\\themes\\keep\\source\\css\\layout\\_partial\\page-template.styl\n在开始位置有：\n.page-template-container &#123;  keep-container(false, 0, 0, 30px, 30px);  .page-template-content &#123;\t.......\n\n加一条，修改为：\n.page-template-container &#123;  keep-container(false, 0, 0, 30px, 30px);  background: rgba(255,255,255,0.9);  .page-template-content &#123;\t.......\n\n","categories":["hexo","美化"],"tags":["hexo"]},{"title":"hexo提交时 Error:Spawn failed 问题","url":"/2022/01/02/hexo%E6%8F%90%E4%BA%A4%E6%97%B6-Error-Spawn-failed-%E9%97%AE%E9%A2%98/","content":"执行 hexo d 后，可能出现以下问题fatal: unable to access &#x27;https://github.com/*/*.github.io.git/&#x27;: Failed to connect to github.com port 443: Timed outFATAL &#123;  err: Error: Spawn failed      at ChildProcess.&lt;anonymous&gt; (E:\\blog\\Hexo\\node_modules\\hexo-util\\lib\\spawn.js:51:21)      at ChildProcess.emit (events.js:315:20)      at ChildProcess.cp.emit (E:\\blog\\Hexo\\node_modules\\cross-spawn\\lib\\enoent.js:34:29)      at Process.ChildProcess._handle.onexit (internal/child_process.js:276:12) &#123;    code: 128  &#125;&#125; Something&#x27;s wrong. \n\n解决方法一可能是网络问题导致，多尝试几次可能会恢复正常\n解决方法二Hexo\\_config.yml中找到以下内容：\ndeploy:  type: git  repository: git@github.com:kaix2301/kaix2301.github.io.git  branch: main\n\nrepository后若原来是HTTPS路径，改为SSH路径\n找该路径方式，进入GitHub中博客所在仓库\n\n","categories":["hexo","问题"],"tags":["hexo"]},{"title":"hexo提交时 nothing to commit 问题","url":"/2022/01/01/hexo%E6%8F%90%E4%BA%A4%E6%97%B6-nothing-to-commit-%E9%97%AE%E9%A2%98/","content":"问题hexo d 后新内容无法提交，提示：\nOn branch masternothing to commit, working directory clean\n\n解决解决方法是删除 “.deploy”依次执行以下指令：\nrm -rf .deployhexo cleanhexo ghexo d\n","categories":["hexo","问题"],"tags":["hexo"]},{"title":"hexo点击效果-彩色爱心或核心价值观","url":"/2022/01/06/hexo%E7%82%B9%E5%87%BB%E6%95%88%E6%9E%9C-%E5%BD%A9%E8%89%B2%E7%88%B1%E5%BF%83%E6%88%96%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E8%A7%82/","content":"建站和美化汇总本站使用的是小众主题keep，没找到此效果在本主题下的实现教程。\n本文参考了大众主题next的点击效果文章，在此主题中实现此效果。\n有一点前端基础的话，结合本文和上述文章，应该可以在大部分主题中实现此效果。\n步骤如下0.效果说明\n爱心和价值观可以选其一，也可以都有。\n1.新建文件在Hexo\\themes\\keep\\source\\js文件夹下新建文本文件\n命名为click.js（js是扩展名)\n将下面两种效果代码复制到文件中保存，可选择其一或者全部\n/*爱心效果*/!function (e, t, a) &#123;  function r() &#123;    for (var e = 0; e &lt; s.length; e++) s[e].alpha &lt;= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = &quot;left:&quot; + s[e].x + &quot;px;top:&quot; + s[e].y + &quot;px;opacity:&quot; + s[e].alpha + &quot;;transform:scale(&quot; + s[e].scale + &quot;,&quot; + s[e].scale + &quot;) rotate(45deg);background:&quot; + s[e].color + &quot;;z-index:99999&quot;);    requestAnimationFrame(r)  &#125;  function n() &#123;    var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick;    e.onclick = function (e) &#123;      t &amp;&amp; t(), o(e)    &#125;  &#125;  function o(e) &#123;    var a = t.createElement(&quot;div&quot;);    a.className = &quot;heart&quot;, s.push(&#123;      el: a,      x: e.clientX - 5,      y: e.clientY - 5,      scale: 1,      alpha: 1,      color: c()    &#125;), t.body.appendChild(a)  &#125;  function i(e) &#123;    var a = t.createElement(&quot;style&quot;);    a.type = &quot;text/css&quot;;    try &#123;      a.appendChild(t.createTextNode(e))    &#125; catch (t) &#123;      a.styleSheet.cssText = e    &#125;    t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)  &#125;  function c() &#123;    return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;  &#125;  var s = [];  e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123;    setTimeout(e, 1e3 / 60)  &#125;, i(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), n(), r()&#125;(window, document);\n\n/* 社会主义核心价值观效果 */var a_idx = 0;jQuery(document).ready(function ($) &#123;  $(&quot;body&quot;).click(function (e) &#123;    var a = new Array(&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;, &quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;);    var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]);    a_idx = (a_idx + 1) % a.length;    var x = e.pageX,      y = e.pageY;    $i.css(&#123;      &quot;z-index&quot;: 100000000,      &quot;top&quot;: y - 20,      &quot;left&quot;: x,      &quot;position&quot;: &quot;absolute&quot;,      &quot;font-weight&quot;: &quot;bold&quot;,      &quot;color&quot;: &quot;#ff6651&quot;    &#125;);    $(&quot;body&quot;).append($i);    $i.animate(&#123;      &quot;top&quot;: y - 180,      &quot;opacity&quot;: 0    &#125;, 1500, function () &#123;      $i.remove();    &#125;);  &#125;);&#125;);\n\n2.引用上述特效文件在Hexo\\themes\\keep\\layout\\layout.ejs中进行引用\n原来：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&lt;%= config.language %&gt;&quot;&gt;&lt;%- partial(&#x27;_partial/head&#x27;) %&gt;&lt;body&gt;&lt;%- body %&gt;&lt;%- partial(&#x27;_partial/scripts&#x27;) %&gt;&lt;/body&gt;&lt;/html&gt;\n\n引用后：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&lt;%= config.language %&gt;&quot;&gt;&lt;%- partial(&#x27;_partial/head&#x27;) %&gt;&lt;body&gt;&lt;%- body %&gt;&lt;%- partial(&#x27;_partial/scripts&#x27;) %&gt;&lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type = &quot;text/javascript&quot; src=&quot;/js/click.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n新增内容为：\n&lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type = &quot;text/javascript&quot; src=&quot;/js/click.js&quot;&gt;&lt;/script&gt;\n\n3.查看效果依次执行以下指令\nhexo cleanhexo ghexo s\n\n4.注意：1.本主题需要加以上两条。其他主题可能只需要第二条就可以。\n2.建议先只加第二条。若爱心和价值观都显示出来，就不用第一条了。若爱心正常，但价值观不显示，则再加上第一条。如果原本不需要加第一条，但是你加了，可能出现未知问题。\n3.若价值观显示出来了，但是不是汉字而是乱码，说明刚刚建立的文件编码格式有问题，要改成 utf-8 。很多文本编辑器都有改编码的途径，网上教程也很多。\n\n4.执行hexo g后会生成public文件夹，js或cs等资源的引入路径，要根据public中的相对路径。因为其他文件是为了生成public而存在的文件，要最终执行的是public中的文件本身。\n","categories":["hexo","美化"],"tags":["hexo"]},{"title":"hexo自定义鼠标指针样式","url":"/2022/01/07/hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BC%A0%E6%A0%87%E6%8C%87%E9%92%88%E6%A0%B7%E5%BC%8F/","content":"建站和美化汇总效果：\n\n实现思路1.通过css代码设置指针图片\nbody &#123;\tcursor: url(https://cdn.jsdelivr.net/gh/kaix2301/pictures/img202201071208706.cur), auto;&#125;a &#123;\tcursor: url(https://cdn.jsdelivr.net/gh/kaix2301/pictures/img202201071205091.cur), auto!important;&#125;\n\n2.注意\n不同主题代码一样，但何处添加此代码，何处引用有所不同。\n一般在Hexo\\themes\\主题名\\source\\css中，或者此文件夹的子文件夹中。\n需要创建新文件添加代码，或者在已有文件中添加代码。\n实现方式在上述css文件夹中，看到下面红色箭头所指内容。\n文件夹中存着许多样式文件，在stytle.styl中引用了所有样式文件。\n\n\n然后照猫画虎，创建my文件夹用来存放自己的样式文件。\n在其中创建mouse.styl文件存入上面的代码（因为其他样式文件都是styl文件，所以自己也用styl）。\n在stytle.styl中添加一条来引用此样式。\n\n\n最后保存，依次执行下面指令，查看效果，已经设置成功。\nhexo cleanhexo ghexo s\n\n其他思路参考此文章：添加js文件并引用，此方法逻辑上应该是可行的，而且比较万能。\n","categories":["hexo","美化"],"tags":["hexo"]},{"title":"hexo顶部底部透明度渐变","url":"/2022/01/08/hexo%E9%A1%B6%E9%83%A8%E5%BA%95%E9%83%A8%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B8%90%E5%8F%98/","content":"建站和美化汇总0.说明起因：设置了背景图片。\n顶部导航条默认为纯白，底部网站信息默认透明背景。\n若全透明则文字受图片干扰看不清，纯白或单纯半透明会突兀，没有过渡。\n故本文设置渐变透明度，使之更协调。\n目标效果：\n\n\n1.顶部1-1.透明度渐变文件Hexo\\themes\\keep\\source\\css\\layout\\_partial\\header.styl中，\n找到下面代码：\n.header-wrapper &#123;  width: 100%;  height: 100%;  box-sizing: border-box;  display: flex;  align-items: center;  justify-content: center;  background: var(--background-color);  padding-top: $scroll-progress-bar-height;  ......\n\n将background的值修改为：\nbackground: linear-gradient(to bottom, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0.4));\n\n1-2.字体加粗为使导航条上文字始终清晰，设置为加粗。\n文件Hexo\\themes\\keep\\source\\css\\layout\\_partial\\header.styl中，\n找到以下代码：\n.menu-item &#123;\tfloat: left;\tposition: relative;\tmargin-left: 30px;\tfont-size: 1rem;\tcursor: pointer;\tcolor: var(--default-text-color);\t......\n\n加一条font-weight: bold，修改结果：\n.menu-item &#123;\tfloat: left;\tposition: relative;\tmargin-left: 30px;\tfont-size: 1rem;\tfont-weight: bold;\tcursor: pointer;\tcolor: var(--default-text-color);\t......\n\n2.底部在文件Hexo\\themes\\keep\\source\\css\\layout\\page.styl中\n找到以下代码：\n.page-main-content-bottom &#123;\twidth: 100%;&#125;\n\n加两条，修改结果：\n.page-main-content-bottom &#123;\twidth: 100%;\tbackground: linear-gradient(to top, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));\tpadding-top: 15px;&#125;\n\n第一条设置过渡透明度，第二条调节此背景覆盖范围。\n","categories":["hexo","美化"],"tags":["hexo"]},{"title":"hexo飘雪飘落叶特效","url":"/2022/01/08/hexo%E9%A3%98%E9%9B%AA%E9%A3%98%E8%90%BD%E5%8F%B6%E7%89%B9%E6%95%88/","content":"建站和美化汇总1.新建js文件在Hexo\\themes\\keep\\source\\js下新建文件snow.js\n2.输入以下代码代码来自：Hexo添加樱花动态效果背景 \nvar stop, staticx;var img = new Image();img.src = &quot;https://cdn.jsdelivr.net/gh/kaix2301/pictures/img202201081103397.png&quot;;function Sakura(x, y, s, r, fn) &#123;    this.x = x;    this.y = y;    this.s = s;    this.r = r;    this.fn = fn;&#125;Sakura.prototype.draw = function (cxt) &#123;    cxt.save();    var xc = 40 * this.s / 4;    cxt.translate(this.x, this.y);    cxt.rotate(this.r);    cxt.drawImage(img, 0, 0, 40 * this.s, 40 * this.s)    cxt.restore();&#125;Sakura.prototype.update = function () &#123;    this.x = this.fn.x(this.x, this.y);    this.y = this.fn.y(this.y, this.y);    this.r = this.fn.r(this.r);    if (this.x &gt; window.innerWidth || this.x &lt; 0 || this.y &gt; window.innerHeight || this.y &lt; 0) &#123;        this.r = getRandom(&#x27;fnr&#x27;);        if (Math.random() &gt; 0.4) &#123;            this.x = getRandom(&#x27;x&#x27;);            this.y = 0;            this.s = getRandom(&#x27;s&#x27;);            this.r = getRandom(&#x27;r&#x27;);        &#125; else &#123;            this.x = window.innerWidth;            this.y = getRandom(&#x27;y&#x27;);            this.s = getRandom(&#x27;s&#x27;);            this.r = getRandom(&#x27;r&#x27;);        &#125;    &#125;&#125;SakuraList = function () &#123;    this.list = [];&#125;SakuraList.prototype.push = function (sakura) &#123;    this.list.push(sakura);&#125;SakuraList.prototype.update = function () &#123;    for (var i = 0, len = this.list.length; i &lt; len; i++) &#123;        this.list[i].update();    &#125;&#125;SakuraList.prototype.draw = function (cxt) &#123;    for (var i = 0, len = this.list.length; i &lt; len; i++) &#123;        this.list[i].draw(cxt);    &#125;&#125;SakuraList.prototype.get = function (i) &#123;    return this.list[i];&#125;SakuraList.prototype.size = function () &#123;    return this.list.length;&#125;function getRandom(option) &#123;    var ret, random;    switch (option) &#123;        case &#x27;x&#x27;:            ret = Math.random() * window.innerWidth;            break;        case &#x27;y&#x27;:            ret = Math.random() * window.innerHeight;            break;        case &#x27;s&#x27;:            ret = Math.random();            break;        case &#x27;r&#x27;:            ret = Math.random() * 6;            break;        case &#x27;fnx&#x27;:            random = -0.5 + Math.random() * 1;            ret = function (x, y) &#123;                return x + 0.5 * random - 1.7;            &#125;;            break;        case &#x27;fny&#x27;:            random = 1.5 + Math.random() * 0.7            ret = function (x, y) &#123;                return y + random;            &#125;;            break;        case &#x27;fnr&#x27;:            random = Math.random() * 0.03;            ret = function (r) &#123;                return r + random;            &#125;;            break;    &#125;    return ret;&#125;function startSakura() &#123;    requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame;    var canvas = document.createElement(&#x27;canvas&#x27;),        cxt;    staticx = true;    canvas.height = window.innerHeight;    canvas.width = window.innerWidth;    canvas.setAttribute(&#x27;style&#x27;, &#x27;position: fixed;left: 0;top: 0;pointer-events: none;&#x27;);    canvas.setAttribute(&#x27;id&#x27;, &#x27;canvas_sakura&#x27;);    document.getElementsByTagName(&#x27;body&#x27;)[0].appendChild(canvas);    cxt = canvas.getContext(&#x27;2d&#x27;);    var sakuraList = new SakuraList();    for (var i = 0; i &lt; 50; i++) &#123;        var sakura, randomX, randomY, randomS, randomR, randomFnx, randomFny;        randomX = getRandom(&#x27;x&#x27;);        randomY = getRandom(&#x27;y&#x27;);        randomR = getRandom(&#x27;r&#x27;);        randomS = getRandom(&#x27;s&#x27;);        randomFnx = getRandom(&#x27;fnx&#x27;);        randomFny = getRandom(&#x27;fny&#x27;);        randomFnR = getRandom(&#x27;fnr&#x27;);        sakura = new Sakura(randomX, randomY, randomS, randomR, &#123;            x: randomFnx,            y: randomFny,            r: randomFnR        &#125;);        sakura.draw(cxt);        sakuraList.push(sakura);    &#125;    stop = requestAnimationFrame(function () &#123;        cxt.clearRect(0, 0, canvas.width, canvas.height);        sakuraList.update();        sakuraList.draw(cxt);        stop = requestAnimationFrame(arguments.callee);    &#125;)&#125;window.onresize = function () &#123;    var canvasSnow = document.getElementById(&#x27;canvas_snow&#x27;);&#125;img.onload = function () &#123;    startSakura();&#125;function stopp() &#123;    if (staticx) &#123;        var child = document.getElementById(&quot;canvas_sakura&quot;);        child.parentNode.removeChild(child);        window.cancelAnimationFrame(stop);        staticx = false;    &#125; else &#123;        startSakura();    &#125;&#125;\n\n3.更换飘浮物上述代码第三行，img.src等于什么图片的地址，就飘什么，可自行更换。\n4.调整密集程度上述代码中间位置找到以下内容：\nSakuraList.prototype.draw = function (cxt) &#123;    for (var i = 0, len = this.list.length; i &lt; len; i++) &#123;        this.list[i].draw(cxt);    &#125;&#125;\n\n第二行默认是i &lt; len，len可以更换为数字，数字越大越密集，数字越小越稀疏。\n5.引用上述js文件各主题可能不同，大部分是在Hexo\\themes\\keep\\layout\\layout.ejs中的body标签里面的最后位置。\n&lt;script type = &quot;text/javascript&quot; src=&quot;/js/snow.js&quot;&gt;&lt;/script&gt;\n\nkeep主题添加后：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&lt;%= config.language %&gt;&quot;&gt;&lt;%- partial(&#x27;_partial/head&#x27;) %&gt;&lt;body&gt;&lt;%- body %&gt;&lt;%- partial(&#x27;_partial/scripts&#x27;) %&gt;&lt;script type = &quot;text/javascript&quot; src=&quot;/js/snow.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n效果可看本站首页。\n","categories":["hexo","美化"],"tags":["hexo"]},{"title":"linux-01VMware网络设置","url":"/2022/01/01/linux-01VMware%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/","content":"VMware+Linux网络设置（联网）1.VMware设置\n\n\n若没有第一个点击右下角个更改设置\n2.桥接模式特点：\na. 默认使用VMnet0，不提供DHCP服务 \nb. 虚拟机与外部主机需要在同一个网段上，与局域网的其它机器没有区别。 \nc. 可以与局域网内其它主机通信，可以与外部网络通信 \nd. 容易与局域网其他主机引起ip地址冲突\n设置：\na. 点击 编辑虚拟机设置—网络适配器—选择桥接模式\n\n\nb. 设置新模式后重启网卡使之生效，\n  systemctl restart network.service  \nc. 查看物理机和linux系统的ip地址，验证特点b\n  centos查看ip：ip addr \n  win10查看ip：执行ipconfig  查看WLAN下ipv4地址\nd. 在物理机和虚拟机中的centos中，分别ping前面查到的ip，可以通信\n  在centos中ping “www.baidu.com” ，可以通信，验证验证特点c\n3.仅主机模式特点： \na. 默认使用VMnet1，提供DHCP服务 \nb. 虚拟机可以和物理主机互相访问，但虚拟机无法访问外部网络\n设置：\na. VMware设置中点击仅主机模式可以设置子网ip范围和子网掩码，一般使用默认即可\nb. 点击 编辑虚拟机设置—网络适配器—选择仅主机模式\nc. 重启网卡\nd. 查看物理机和linux系统的ip地址\n  centos查看ip：ip addr \n  win10查看ip：执行ipconfig  查看VMnet1下ipv4地址\nd. 在物理机和虚拟机中的centos中，分别ping前面查到的ip，可以通信\n  在centos中ping “www.baidu.com” ，不可以通信\n3.NAT模式特点： \na. 默认使用VMnet8，提供DHCP服务\nb. 虚拟机可以和物理主机互相访问，可访问外部网络 \nc. 局域网内其它机器访问不了\n设置：\na. VMware设置中点击仅主机模式可以设置子网ip范围和子网掩码，一般使用默认即可\nb. 点击 编辑虚拟机设置—网络适配器—选择NAT模式\nc. 重启网卡\nd. 查看物理机和linux系统的ip地址\n  centos查看ip：ip addr \n  win10查看ip：执行ipconfig  查看VMnet8下ipv4地址\nd. 在物理机和虚拟机中的centos中，分别ping前面查到的ip，可以通信\n  在centos中ping “www.baidu.com” ，可以通信\n","categories":["linux","虚拟机"],"tags":["linux","虚拟机"]},{"title":"markdown公式总结","url":"/2022/01/19/markdown%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/","content":"\n参考文章：markdown语法 公式篇本文只记录我常用的，详见上述文章\n\n\n\n\n符号\n效果\n语法\n\n\n\n上标\n\nx^{yz}\n\n\n下标\n\nx_{yz}\n\n\n分数\n\n\\frac{1}{2}\n\n\n省略\n\n\\cdots\n\n\n对数\n\n\\log_{12}144\n\n\n乘号\n\n\\times\n\n\n除号\n\n\\div\n\n\n","categories":["hexo","markdown"],"tags":["hexo","markdown"]},{"title":"typora自动化使用图床","url":"/2022/01/02/typora%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BA%8A/","content":"\n上文中使用Github+PicGo配置好了图床，这里在typora中使用\n\n效果直接将图片复制到typora编辑页面后，图片自动上传到图床，图片地址也自动更新为在线链接\n配置方式1.打开typora，点击：文件—偏好设置—图像\n2.进行如下配置\n\n\n3.点击“验证图片上传选项”，显示成功，配置完毕\n","categories":["图床"],"tags":["图床","typora"]},{"title":"win10彻底关闭资讯和兴趣","url":"/2022/01/05/win10%E5%BD%BB%E5%BA%95%E5%85%B3%E9%97%AD%E8%B5%84%E8%AE%AF%E5%92%8C%E5%85%B4%E8%B6%A3/","content":"关闭原因\n某版本更新后，任务栏右下角默认开启资讯和兴趣\n对我来说，没有在这里看东西的习惯\n天气预报不准到离谱\n\n关闭方法1.任务栏关闭鼠标放到任务栏—右键—资讯和兴趣—关闭\n2.组策略关闭win+R—输入gpedit.msc后回车\n依次打开：计算机配置、管理模板、Windows组件\n\n\nWindows组件文件夹中，靠后位置有“资讯和兴趣”，点击\n在右侧依次点击：\n\n","categories":["电脑"],"tags":["win10"]},{"title":"win10直接关闭和恢复桌面图标箭头","url":"/2022/01/05/win10%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%AD%E5%92%8C%E6%81%A2%E5%A4%8D%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E7%AE%AD%E5%A4%B4/","content":"目标简单删除和恢复桌面图标箭头，不需要安装第三方软件\n方法准备显示文件扩展名，若本来就是已显示状态，忽略此步。\n不设置的话无法修改扩展名。\n随便打开一个文件夹，按下图操作即可。\n\n\n删除新建文本文件&gt;&gt;把以下代码复制粘贴到其中保存\nreg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons&quot; /v 29 /d &quot;%systemroot%\\system32\\imageres.dll,197&quot; /t reg_sz /ftaskkill /f /im explorer.exeattrib -s -r -h &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot;del &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot; /f /qstart explorerpause\n\n重命名为remove.bat，右键点击，选择以管理员身份运行，然后箭头消失。\n恢复新建文本文件&gt;&gt;把以下代码复制粘贴到其中保存\nreg delete &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons&quot; /v 29 /ftaskkill /f /im explorer.exeattrib -s -r -h &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot;del &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot; /f /qstart explorerpause\n\n重命名为recover.bat，右键点击，选择以管理员身份运行，然后箭头出现。\n说明链接文件显示箭头，是为区分普通文件和链接文件的系统内置设置，普通用户改不了，须管理员身份运行\n执行外来代码，有可能安全中心会警告吧，反正我的没有。有的话可以暂时关一下安全中心。\n两段代码是我以前在别人博文中存下来的，现在找不到那篇文章了。\n","categories":["电脑"],"tags":["win10"]},{"title":"失踪人口又出现了","url":"/2022/05/13/%E5%A4%B1%E8%B8%AA%E4%BA%BA%E5%8F%A3%E5%8F%88%E5%87%BA%E7%8E%B0%E4%BA%86/","content":"很久不更啦~\n年初一直在学习，由于时间紧内容多，很多东西没来得及整理。\n还有考研复试、联系导师、再参加导师的面试等事情，一直也没有闲下来。\n到四月中旬终于不忙啦，然后一直在玩哈哈。\n接下来就，继续玩吧，更新随缘吧~\n","categories":["个人"],"tags":["个人"]},{"title":"数据预处理—matplotlib","url":"/2022/06/25/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E2%80%94matplotlib/","content":"（多图预警，图存在 GitHub，加载慢）\n1.简介1.1导入import matplotlib.pyplot as plt\n\n1.2折线图 / x轴y轴# 只指定y轴，x轴默认列表索引plt.plot([3,1,4,5,2])plt.ylabel(&quot;grade&quot;)plt.show()\n\n\n# 同时指定x、y轴plt.plot([0,2,4,6,8], [3,1,4,5,2])plt.ylabel(&quot;grade&quot;)plt.show()\n\n\n# 同时指定x、y轴，指定x轴尺度-1~10，y轴0~6plt.plot([0,2,4,6,8], [3,1,4,5,2])plt.ylabel(&quot;grade&quot;)plt.axis([-2, 10, 0, 6])plt.show()\n\n\n1.3函数图像a = np.arange(0.0, 5.0, 0.02) # x轴 def f(t):    # 指数函数    return np.exp(t)plt.subplot(211) # 2行1列，第1块plt.plot(a, f(a)) # 指数函数plt.subplot(2,1,2) # 2行1列，第2块plt.plot(a, np.cos(2 * np.pi * a)) # 余弦函数plt.show()\n\n\n1.4网格线plt.plot([0,2,4,6,8], [3,1,4,5,2])plt.ylabel(&quot;grade&quot;)plt.grid(True) # 网格线开启plt.show()\n\n2.plot函数plt.plot(x, y, format_string, **kwargs)\n\nx：X轴数据，列表或数组，可选\ny：Y轴数据，列表或数组\nformat_string：控制曲线的格式字符串，可选\n**kwargs：第二组或更多(×,y,format_string)，多条曲线\n\n当绘制多条曲线时，各条曲线的x不能省略\n2.1基本用法a = np.arange(10)plt.plot(a, a*1.5, a, a*2.5, a, a*3.5)plt.show()\n\n\n2.2格式控制format_string由颜色字符、风格字符和标记字符组成\n\n颜色字符：线条和点的颜色\n风格字符：线条的样子\n标记字符：点的样子\n\n颜色字符：\n\n\n\n颜色字符\n说明\n颜色字符\n说明\n\n\n\n‘b’\n蓝色\n‘m’\n洋红色magenta\n\n\n‘g’\n绿色\n‘y’\n黄色\n\n\n‘r’\n红色\n‘k’\n黑色\n\n\n‘c’\n青绿色cyan\n‘w’\n白色\n\n\n‘#008000’\nRGB\n‘0.8’\n灰度值字符串\n\n\n风格字符：\n\n\n\n风格字符\n说明\n风格字符\n说明\n\n\n\n‘-‘\n实线\n‘:’\n虚线\n\n\n‘–’\n破折线\n‘-.’\n点划线\n\n\n‘’\n无线条\n\n\n\n\n标记字符：\n\n\n\n标记字符\n说明\n标记字符\n说明\n\n\n\n‘.’\n点标记\n‘s’\n实心方形标记\n\n\n‘,’\n像素标记（极小点）\n‘p’\n实心五角标记\n\n\n‘o’\n实心圈标记\n‘*’\n星形标记\n\n\n‘v’\n倒三角标记\n‘h’\n竖六边形标记\n\n\n‘^’\n上三角标记\n‘H’\n横六边形标记\n\n\n‘&gt;’\n右三角标记\n‘+’\n十字标记\n\n\n‘&lt;’\n左三角标记\n‘x’\nx标记\n\n\n‘1’\n下花三角标记\n‘D’\n菱形标记\n\n\n‘2’\n上花三角标记\n‘d’\n瘦菱形标记\n\n\n‘3’\n左花三角标记\n‘|’\n垂直线标记\n\n\n‘4’\n右花三角标记\n\n\n\n\na = np.arange(10)# 都指定；不指定风格；不指定标记plt.plot(a, a*1.5, &#x27;g4:&#x27;, a, a*2.5, &#x27;ch&#x27;, a, a*3.5, &#x27;y-.&#x27;)plt.show()\n\n\n3.中文显示\n\n\n中文字体\n说明\n中文字体\n说明\n\n\n\n‘SimHei’\n中文黑体\n‘FangSong’\n中文仿宋\n\n\n‘Kaiti’\n中文楷体\n‘YouYuan’\n中文幼圆\n\n\n‘LiSu’\n中文隶书\n‘STSong’\n华文宋体\n\n\n3.1全局中文步骤\n\n导入matplotlib\n调用matplotlib的rcParams\n\n\n\n\nrcParams属性\n说明\n\n\n\n‘font.family’\n字体名字，见上表\n\n\n‘font.style’\n字体风格，正常’normal’，斜体’italic’\n\n\n‘font.size’\n字体大小，’large’、’x-small’或整数字号\n\n\n使用方法（实例）：\nimport numpy as npimport matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams[&#x27;font.family&#x27;]=&#x27;STSong&#x27;matplotlib.rcParams[&#x27;font.size&#x27;]=20a = np.arange(0.0, 5.0, 0.02)plt.xlabel(&#x27;时间&#x27;)plt.ylabel(&#x27;振幅&#x27;)plt.plot(a, np.cos(2*np.pi*a))plt.show()\n\n\n3.2局部中文import numpy as npimport matplotlib.pyplot as plta = np.arange(0.0, 5.0, 0.02)# 只改变xlabel和ylabelplt.xlabel(&#x27;时间&#x27;, fontproperties=&#x27;SimHei&#x27;, fontsize=&#x27;20&#x27;)plt.ylabel(&#x27;振幅&#x27;, fontproperties=&#x27;SimHei&#x27;, fontsize=&#x27;20&#x27;, color=&#x27;green&#x27;)plt.plot(a, np.cos(2*np.pi*a))plt.show()\n\n\n4.文本显示\n\n\n函数\n说明\n函数\n说明\n\n\n\nplt.xlabel()\nX轴文本标签\nplt.text()\n任意位置增加文本\n\n\nplt.ylabel()\nY轴文本标签\nplt.annotate()\n任意位置增加带箭头注解\n\n\nplt.title()\n图形标题\n\n\n\n\nplt.text(0, 1, r&#39;$\\mu=100$&#39;, fontsize=&#39;15&#39;)\n\n在(0,1)位置输出\n内容$\\mu=100$\n字体大小为15\n\nplt.annotate(r&#39;$\\mu=100$&#39;, fontsize=&#39;15&#39;, xy=(2,1), xytext=(3,1.5), arrowprops=dict(facecolor=&#39;black&#39;, shrink=0.1, width=2))\n\n内容$\\mu=100$\n字体大小为15\n箭头坐标(2,1)\n文字坐标(3,1.5)\n箭头样式（黑色，线两端与坐标点距离0.1，宽2）\n\na = np.arange(0.0, 5.0, 0.02)plt.plot(a, np.cos(2*np.pi*a), &#x27;r--&#x27;)plt.xlabel(&#x27;时间&#x27;, fontproperties=&#x27;SimHei&#x27;, fontsize=&#x27;20&#x27;)plt.ylabel(&#x27;振幅&#x27;, fontproperties=&#x27;SimHei&#x27;, fontsize=&#x27;20&#x27;, color=&#x27;blue&#x27;)plt.title(&#x27;正弦波&#x27;, fontproperties=&#x27;SimHei&#x27;, fontsize=&#x27;25&#x27;)plt.text(0, 1, r&#x27;$\\mu=100$&#x27;, fontsize=&#x27;15&#x27;)plt.annotate(r&#x27;$\\mu=100$&#x27;, fontsize=&#x27;15&#x27;, xy=(2,1), xytext=(3,1.5),              arrowprops=dict(facecolor=&#x27;black&#x27;, shrink=0.1, width=2))plt.axis([-1, 6, -2, 2])plt.grid(True)plt.show()\n\n\n5.子绘图区域5.1简单划分# 分为nrows行，ncols列，共nrows*ncols个区域# 图画在第plot_number个区域，横着数plt.subplot(nrows, ncols, plot_number)# 逗号可以省略plt.subplot(3, 2, 4)plt.subplot(324)\n\n演示：\na = np.arange(0.0, 5.0, 0.02) # x轴 def f(t):    # 指数函数    return np.exp(t)plt.subplot(211) # 2行1列，第1块plt.plot(a, f(a)) # 指数函数plt.subplot(2,1,2) # 2行1列，第2块plt.plot(a, np.cos(2 * np.pi * a)) # 余弦函数plt.show()\n\n\n5.2复杂划分函数：plt.subplot2grid(GridSpec, CurSpec, colspan=c, rowspan=r)\nplt.subplot2grid((3,4), (0,2), colspan=2, rowspan=3)\n\n划分为3行4列\n根据下标(0,2)选中第1行第3列\n横向长度为2，纵向长度为3的区域\n\na = np.arange(0.0, 5.0, 0.02)plt.subplot2grid((3,4), (1,0), colspan=2)plt.plot(a, np.cos(2*np.pi*a), &#x27;r--&#x27;)plt.subplot2grid((3,4), (2,1))plt.plot([0,2,4,6,8], [3,1,4,5,2])plt.subplot2grid((3,4), (0,2), colspan=2, rowspan=3)plt.plot([0,2,4,6,8], [3,1,4,5,2])plt.show()\n\n\n6.饼状图labels =  [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;D&#x27;, &#x27;E&#x27;] # 标签sizes = [15, 30, 45, 10] # 占比explode = (0, 0.1, 0, 0) # 距离中心距离&quot;&quot;&quot;sizes,explode,labels见上面解释autopct 数字格式shadow 阴影startangle开始角度，默认x轴正向开始，90y轴正向开始&quot;&quot;&quot;plt.pie(sizes, explode=explode, labels=labels, autopct=&#x27;%1.1f%%&#x27;, shadow=False, startangle=90)# 若图为椭圆，通过此句使之成为圆形plt.axis(&#x27;equal&#x27;)plt.show()\n\n\n7.柱状图x = np.array([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;])y = np.array([12, 22, 6, 18])plt.subplot(1,3,1)plt.bar(x, y)plt.subplot(1,3,2)plt.bar(x, y, width=0.5, color = [&quot;#4CAF50&quot;,&quot;red&quot;,&quot;hotpink&quot;,&quot;#556B2F&quot;])plt.subplot(1,3,3)plt.barh(x, y, height=0.5, color = [&quot;#4CAF50&quot;,&quot;red&quot;,&quot;hotpink&quot;,&quot;#556B2F&quot;])plt.show()&quot;&quot;&quot;bar竖立，使用width调节柱状宽度barh横立，使用height调节柱状宽度color：只指定一个，则所有柱状同为此色&quot;&quot;&quot;\n\n\n8.散点图matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, *, edgecolors=None, plotnonfinite=False, data=None, **kwargs)\n参数说明：\nx，y：长度相同的数组，也就是我们即将绘制散点图的数据点，输入数据。\ns：点的大小，默认 20，也可以是个数组，数组每个参数为对应点的大小。\nc：点的颜色，默认蓝色 ‘b’，也可以是个 RGB 或 RGBA 二维行数组。\nmarker：点的样式，默认小圆圈 ‘o’。\ncmap：Colormap，默认 None，标量或者是一个 colormap 的名字，只有 c 是一个浮点数数组的时才使用。如果没有申明就是 image.cmap。\nnorm：Normalize，默认 None，数据亮度在 0-1 之间，只有 c 是一个浮点数的数组的时才使用。\nvmin，vmax：：亮度设置，在 norm 参数存在时会忽略。\nalpha：：透明度设置，0-1 之间，默认 None，即不透明。\nlinewidths：：标记点的长度。\nedgecolors：：颜色或颜色序列，默认为 ‘face’，可选值有 ‘face’, ‘none’, None。\nplotnonfinite：：布尔值，设置是否使用非限定的 c ( inf, -inf 或 nan) 绘制点。\n**kwargs：：其他参数。\nx = np.array([1, 2, 3, 4, 5, 6, 7, 8])y = np.array([1, 4, 9, 16, 7, 11, 23, 18])sizes = np.array([20,50,100,200,500,1000,60,90])colors = np.array([&quot;red&quot;,&quot;green&quot;,&quot;black&quot;,&quot;orange&quot;,&quot;purple&quot;,&quot;beige&quot;,&quot;cyan&quot;,&quot;magenta&quot;])plt.subplot(3,2,1)plt.scatter(x, y)plt.subplot(3,2,2)plt.scatter(x, y, s=sizes)plt.subplot(3,2,3)plt.scatter(x, y, c=colors)plt.subplot(3,2,4)plt.scatter(x, y, s=sizes, c=colors)plt.show()\n\n\n通过颜色条设置颜色 见Matplotlib 散点图 | 菜鸟教程 (runoob.com)\n同一图中多组数据：\nx = np.array([5,7,8,7,2,17,2,9,4,11,12,9,6])y = np.array([99,86,87,88,111,86,103,87,94,78,77,85,86])plt.scatter(x, y, color = &#x27;hotpink&#x27;)x = np.array([2,2,8,1,15,8,12,9,7,3,11,4,7,14,12])y = np.array([100,105,84,105,90,99,90,95,94,100,79,112,91,80,85])plt.scatter(x, y, color = &#x27;#88c999&#x27;)plt.show()\n\n\n9.直方图plt.hist(x, bins=None, range=None, density=None, weights=None, cumulative=False, bottom=None, histtype=&#39;bar&#39;, align=&#39;mid&#39;, orientation=&#39;vertical&#39;, rwidth=None, log=False, color=None, label=None, stacked=False, normed=None, *, data=None, **kwargs)\n\nx：数据\nbins：取值范围分为bins份，默认10\ndensity：False频数，True频率\nhisttype：{‘bar’, ‘barstacked’, ‘step’, ‘stepfilled’}。’bar’是传统的条形直方图；’barstacked’是堆叠的条形直方图；’step’是未填充的条形直方图，只有外边框；’stepfilled’是有填充的直方图。当histtype取值为’step’或’stepfilled’，rwidth设置失效，即不能指定柱子之间的间隔，默认连接在一起。\nalpha：透明度\n\n# 生成符合正态分布的随机数组np.random.seed(0)mu, sigma = 100, 20 # 均值，标准差a = np.random.normal(mu,sigma,size=100)plt.hist(a, 15, density=False, histtype=&#x27;stepfilled&#x27;, color=&#x27;b&#x27;, alpha=0.75)plt.show()\n\n\n","categories":["数据预处理"],"tags":["数据预处理","matplotlib"]},{"title":"每周总结","url":"/2022/01/09/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/","content":"\n  c85e659fca688c979e73212fbf2476f3c6a2f6a225bcd8d8d33c3eb1a8c7a9fa4c515380e8ae675523b08292dab1f37f14d3fb2b96bd03b111e1bb8297af3ee87c761149ec643353d56159c5b73317559ea94c6a94679b0c4a04adb05317a9c01ade422526ba830c4c2793cd48e3819c1ece0a1c943da78c9788feeb022483c402ac58916b5f56874bfdf85428de0ace9d032546c961cfe75519527d0f865126966b8221d8250294a44a38ad15081ae08bd9f186ab2138e94fa71b417d146b5b5b0ecbb4b652eb44708c9b19cdc0157a3f6b32cd00008f34f335bc3b945e2fa2f283c17cb52ab670642f0274b40dc5542c4157af0ca61d1c0a845c706bd4f2ed0080d9938d56ebc343c16eadfb2a1ab2e514a41d5e126111003ba25edc53e3eff28ebaba39bc43f1ae9720b048813eb91fed33310c2546347f08c5b7942e374a3810afe27c48bbde33b44907d11cdaed469fb07f68fb07849d01e4a6acc75d37e9b1e3ecea32973d60d19dc6282fcdd4f780451285cfc29dbdc8bca7dc759f111de27ab7faa7c61dec63c9a13abd99df10f4861a875caf267b88b190341925c0cf393d247f0876ab7cb66a00cd8af69fb52b5cc104344cf72822072736119e345a4bad6188250229d80d043d11ef4a46ba91e8094ee00f6b8d2d414963ee23bea22d701451eaab2c3258694729957d18f55100cd44ea9ba0223c8ba5beeaa9c9fb2923c0e59136fc3f5d10d7f25e9e53e56772a1f1e72c53c967e812bb64bc558cd04aaa3a5d76818f1e1b06705081cc1f95f2a19c7089821aed17df7fe8facd83b5fb3e710b1ed4c28f56c46e3f7b46e7cb14d14610fa9b27d315cbca2dc28cf7655dfee35920192f253531e8a9f31d\n  \n    \n      \n      \n        这里需要密码😛\n      \n    \n  \n\n","categories":["个人"],"tags":["个人"]},{"title":"算法-01输入输出","url":"/2022/01/05/%E7%AE%97%E6%B3%95-01%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","content":"测试测试\n测试测试\n测试测试\n测试测试\n测试测试\n","categories":["算法","基本"],"tags":["算法"]},{"title":"计算机网络-01概念和功能","url":"/2022/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-01%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8A%9F%E8%83%BD/","content":"1.概念计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。特点是互连和自治。\n\n\n\n核心问题\n回答\n\n\n\n是什么\n计算机系统\n\n\n怎么连接\n通信设备与线路\n\n\n怎么实现\n软件\n\n\n目标\n资源共享，信息传递\n\n\n特点\n互连和自治（无主从关系）\n\n\n2.功能\n\n\n常见功能\n简介\n\n\n\n* 数据通信\n最基本，最重要\n\n\n* 资源共享\n共享硬件、软件、数据\n\n\n分布式处理\n同一任务分给多计算机\n\n\n提高可靠性\n基于分布式，一台坏了其他替代\n\n\n负载均衡\n基于分布式，多台之间的平衡\n\n\n3.分类按分布范围\n广域网(WAN)：交换技术\n城域网(MAN)：以太网技术\n局域网(LAN)：广播技术\n个人区域网(PAN)\n\n按拓扑结构\n总线：简单；效率低；任意点故障敏感\n星：中心一般是路由器或交换机；成本高；中心故障敏感\n环：令牌环局域网；环中单向传输\n网：可靠性高；成本高；控制复杂\n\n按交换技术\n电路交换\n报文交换\n分组交换\n\n4.组成按组成部分：硬件 + 软件 + 协议(核心)\n按工作方式：边缘(主机) + 核心(网络和路由器)\n按功能组成：通信子网 + 资源子网\n5.发展5-1.发展阶段\n\n\n发展阶段\n简介\n\n\n\nARPAnet 阿帕网\n只可连接同类型网络\n\n\ninternet 互联网\n不同网络的互连\n\n\nInternet 因特网\n最大的互联网（TCP/IP）\n\n\n5-2.三级结构（第二阶段）\n\n5-3.多层次ISP结构（第三阶段）\nISP：因特网服务商，如移动联通等\nIXP：因特网交换点，允许两个网络直接相连并交换分组，更加有效地利用网络资源，部分国家和地区也称之为NAP（网络接入点）。\n","categories":["计算机网络","体系结构"],"tags":["计算机网络"]},{"title":"计算机网络-02标准化","url":"/2022/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-02%E6%A0%87%E5%87%86%E5%8C%96/","content":"1.标准化意义不同厂商的软硬件之间的相互连通\n2.标准分类法定标准：权威机构指定，如OSI\n事实标准：竞争中确立，如TCP/IP\n3.因特网标准形式RFC—Request for Comment\n因特网标准 =&gt;RFC （充要关系）\n4.因特网标准制定流程\n\n\n阶段\n简介\n\n\n\n因特网草案\n不是RFC\n\n\n建议标准\n成为RFC\n\n\n草案标准\n建议标准经过评论和修改\n\n\n因特网标准\n草案标准经过权威机构审核\n\n\n草案标准现已取消\n5.重要组织国际标准化组织ISO制定过：OSI模型，HDLC协议等\n","categories":["计算机网络","体系结构"],"tags":["计算机网络"]},{"title":"计算机网络-03性能指标","url":"/2022/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-03%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/","content":"0.导图\n\n1.数据率比特：位（0011010—7bit数据）\n数据率：单位时间内，数字信道上，传送数据位数，的速率\n单位：b/s, kb/s, Mb/s, Gb/s, Tb/s\n注意：速率单位：相邻单位间，1000倍存储容量：相邻单位间，2^10倍1Mb/s = 1000kb/s，1MB = 2^10KB\n2.带宽原指：某信号最高最低频率之差\n计网中指：某一点到另一点所能通过的“最高数据率”通俗讲：网络设备支持的最高极限速度注意：指向链路发送数据的数据率，与链路中传播速率无关\n单位：b/s, kb/s, Mb/s, Gb/s, Tb/s\n3.吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。\n带宽指理论上最高数据率，吞吐量就指事实数据率。\n单位：b/s, kb/s, Mb/s, Gb/s, Tb/s\n4.时延\n\n\n时延\n简介\n\n\n\n发送(传输)时延\n开始发送到全部发送到链路的时间\n\n\n传播时延\n取决于链路长度和电磁波传播速度\n\n\n排队时延\n等待输入输出链路可以使用的时间\n\n\n处理时延\n检查错误，找出口\n\n\n发送时延 = 数据长度 / 信道带宽(发送速率)\n传播时延 = 信道长度 / 电磁波信道传播速率\n单位：s\n5.时延带宽积时延带宽积 = 传播时延 * 带宽 \n含义：容量；以bit为单位的链路长度；链路上有多少bit。\n单位：bit\n6.往返时间RTT从发送方发送第一个bit数据开始，到发送方收到来自接收方的第一个bit的确认信息为止，经历的总时间。\nRTT = 往返传播时延 + 末端处理时间\n其中主要是往返传播时延（传播时延*2）\n7.利用率信道利用率 = 有数据通过的时间 / 总时间\n网络利用率 = 信道利用率的加权平均值\n利用率与时延关系，参考马路上车辆数量的影响\n\n","categories":["计算机网络","体系结构"],"tags":["计算机网络"]},{"title":"计算机网络-04分层结构","url":"/2022/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-04%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/","content":"分层原因各层实现各自的功能，更有条理，更容易解决网络传输中各种问题。\n分层原则1.各层之间相互独立，每层实现一种相对独立的功能。2.每层之间界限自然清晰，相互交流尽可能少。3.结构上可分割开，每层都采用最合适的技术来实现。4.保持下层对上层的独立，上层单向使用下层提供的服务。5.整个分层结构能促进标准化工作。\n基本概念1.实体第n层中的活动元素称为n层实体。同一层的实体叫对等实体。\n2.协议为进行网络中的对等实体数据交换而建立的规则、标准或约定【水平】\n\n\n\n内容\n简介\n\n\n\n语法\n规定传输数据的格式\n\n\n语义\n规定所要完成的功能\n\n\n同步\n规定各种操作的顺序\n\n\n3.接口访问服务点SAP上层使用下层服务的入口\n4.服务下层为相邻上层提供的功能调用【垂直】\n5.数据组成\n\n\n\n\n\n\n\n\nSDU服务数据单元\n为完成用户所要求的功能而应传送的数据\n\n\nPCI协议控制信息\n控制协议操作的信息\n\n\nPDU协议数据单元\n对等层次之间传送的数据单位\n\n\nPDU = PCI + SDU本层PDU = 下层SDU\n总结\n网络体系结构是从功能上描述计算机网络结构。\n网络体系结构是分层结构。\n每层遵循某个/些网络协议以完成本层功能。\n计算机网络体系结构是计算机网络的各层及其协议的集合。\n向上层提供服务时，此服务不仅包含本层本身的功能，还包含由下层服务提供的功能。\n仅在相邻层间有接口，且所提供服务的实现细节对上一层完全屏蔽。\n体系结构是抽象的，而实现是指能运行的一些软件和硬件。\n\n","categories":["计算机网络","体系结构"],"tags":["计算机网络"]},{"title":"计算机网络-05OSI参考模型","url":"/2022/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-05OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/","content":"OSI模型\n通信过程\n\n上四层：端到端，逻辑上起点终点直接相连\n下三层：点到点，传输过程中每个经过的点都关注\n发送过程中不停打包，接收过程中不停拆包：\n\n\n各层介绍1.应用层能和用户交互且能产生网络流量（可以联网）的程序。\n常用服务以及协议：\n\n文件传输—FTP\n电子邮件—SMTP\n万维网—HTTP\n\n2.表示层用于处理在两个通信系统中交换信息的表示方式（语法和语义)\n主要功能：\n\n数据格式变换（翻译为看得懂的形式）\n数据加密和解密\n数据压缩和恢复\n\n3.会话层会话 / 建立同步(SYN)：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据。\n主要功能：\n\n建立、管理、终止会话\n校验点，会话再通信失效时从校验点恢复通信\n\n4.传输层负责主机中两个进程的通信，即端到端的通信。\n传输单位：报文段或用户数据报。\n主要功能：\n\n可靠传输（收到确认信息再发）\n不可靠传输（无确认机制）\n差错控制\n流量控制（发送接收速度控制）\n复用分用（把一段数据拆开分别交给正确的进程）\n\n主要协议：TCP，UDP\n5.网络层把分组从源端传到目的端，提供通信服务。\n传输单位：数据报。(数据报长时，切割为分组)\n主要功能：\n\n路由选择\n流量控制\n差错控制\n拥塞控制\n\n拥塞控制是针对全体结点，流量控制正对发送端接收端。\n主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF\n6.数据链路层是把网络层传下来的数据报组装成帧。\n传输单位：帧。\n主要功能：\n\n成帧—定义帧的开始和结束\n差错控制—帧错+位错\n流量控制\n访问（接入）控制—控制对信道的访问，比如广播式信道需独占\n\n主要协议：SDLC、HDLC、PPP、STP\n7.物理层在物理媒体上实现比特流的透明传输。\n传输单位是比特。\n透明传输：无论数据是何比特组合,都应能在链路上传送。\n主要功能：\n\n定义接口特性—引脚等\n定义传输模式—单工、半双工、双工\n定义传输速率\n比特同步\n比特编码—差分曼切斯特编码等\n\n主要协议：Rj45、802.3\n","categories":["计算机网络","体系结构"],"tags":["计算机网络"]},{"title":"计算机网络-06OSI_TCP/IP_5层模型","url":"/2022/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-06OSI-TCP-IP-5%E5%B1%82%E6%A8%A1%E5%9E%8B/","content":"OSI VS TCP/IP1.关系\n2.同分层；基于独立协议栈的概念；实现异构网络互联。\n3.异\nOSI定义了服务、协议、接口\nOSI模型先于协议，不偏向任何协议；TCP/IP模型由协议总结而出，偏向IP协议。\n\n\n\n\n\nISO/OSI\nTCP/IP\n\n\n\n传输层\n面向连接\n无连接+面向连接\n\n\n网络层\n无连接+面向连接\n无连接\n\n\n5层参考模型综合OSI和TCP/IP的优点，一般用于学习，现实中不用。\n\n\n\n\n功能\n协议\n\n\n\n应用\n支持各种网络应用\nFTP、SMTP、HTTP等\n\n\n传输\n进程间数据传输\nTCP、UDP等\n\n\n网络\n数据分组的路由和转发\nIP、ICMP、OSPF等\n\n\n数据链据\n数据报成帧\nPPP、Ethernet等\n\n\n物理\n比特传输\n\n\n\n包装和拆包过程：\n\n","categories":["计算机网络","体系结构"],"tags":["计算机网络"]},{"title":"计算机网络-07物理层概念和接口特性","url":"/2022/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-07%E7%89%A9%E7%90%86%E5%B1%82%E6%A6%82%E5%BF%B5%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%80%A7/","content":"基本概念1.是什么物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指”具体的传输媒体“。\n2.干什么确定与传输媒体接口有关的一些特性（定义标准）\n接口特性1.机械特性定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。\n如：网线的统一接口\n2.电气特性规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。\n3.功能特性指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。\n4.规程特性（过程特性）定义各条物理线路的工作规程和时序关系。\n","categories":["计算机网络","物理层"],"tags":["计算机网络"]},{"title":"计算机网络-08数据通信基本概念","url":"/2022/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-08%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"1.经典模型\n\n2.基本概念2-1.数据传送信息的实体，通常是有意义的符号序列。如0/1序列。\n2-2.信号数据的电气/电磁的表现，是数据在传输过程中的存在形式。\n数字信号/离散信号：代表消息的参数的取值是离散的。\n模拟信号/连续信号：代表消息的参数的取值是连续的。\n2-3.信源/信宿信源︰产生和发送数据的源头。\n信宿︰接收数据的终点。\n2-4.信道信号的传输媒介。\n一般用来表示向某一个方向传送信息的介质。\n一条通信线路往往包含一条发送信道和一条接收信道。\n按传输信号分为：模拟、数字信道。\n按传输介质分为：有线、无线信道。\n3.速率相关概念3-1.码元\n\n上图左 — 3个2进制码元，上图右 — 5个4进制码元。\n码元的离散状态有M个，称之为M进制码元。\n4进制码元，四种状态可用00,01,10,11表示，一个码元携带2bit数据。\n2进制码元，码元数等于携带数据bit数。\n3-2.传输速率码元传输速率（码元速率、波形速率、调制速率、符号速率）\n含义：一秒传输多少码元，只与码元长度T(一个码元所需时间)有关\n信息传输速率（信息速率、比特率）\n含义：一秒传输多少二进制位（bit数）\n3-3.带宽模拟信号系统中指：某信号最高最低频率之差\n数字设备中指：某一点到另一点所能通过的“最高数据率”，表示传输数据能力。\n","categories":["计算机网络","物理层"],"tags":["计算机网络"]},{"title":"计算机网络-09通信/传输方式","url":"/2022/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-09%E9%80%9A%E4%BF%A1-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/","content":"1.单工/半双工/双工单工：需一条信道，仅可单向\n半双工：需两条信道，双向均可，但不可同时双向\n双工：需两条信道，可同时双向\n2.串行/并行串行1个字符的8位二进制数，按由低位到高位的顺序，依次发送。\n速度慢、费用低、适合远距离。\n并行1个字符的8位二进制数，同时通过多条信道发送。\n速度快、费用高、适合近距离。\n3.同步/异步同步数据传送以一个数据区块为单位，因此同步传输又称为区块传输。\n传送数据时，先送出1个或多个同步字符，再送出整批的数据。\n\n\n\n同步\n同步\n数据\n数据\n数据\n数据\n\n\n\n异步将比特分成小组进行传送，小组可以是8位的1个字符或更长。\n发送方可在任何时刻发送，接收方不知道它们会在何时到达。\n传送数据时，加一个字符起始位和一个字符终止位。\n\n\n\n终止\nbit1\nbit2\nbit3\nbit4\n起始\n\n\n\n","categories":["计算机网络","物理层"],"tags":["计算机网络"]},{"title":"计算机网络-10奈氏准则香浓定理","url":"/2022/01/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-10%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99%E9%A6%99%E6%B5%93%E5%AE%9A%E7%90%86/","content":"1.失真1-1含义发送时信号清晰有规律，由于现实中信道上有噪声、干扰和带宽限制等，接收时信号已经变得没那么清晰\n\n\n1-2影响因素与失真程度关系：\n\n码元传输速率（正相关）\n信号传输距离（正相关）\n噪声干扰（正相关）\n传输媒体质量（负相关）\n\n1-3码间串扰接收端收到的信号波形失去了码元之间清晰界限的现象。一般出现在传输频率过高时。\n2.奈氏准则2-1含义在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。\n2-2解释\n在信道中，码元传输速率是有上限。若传输速率超过上限，就会出现严重的码间串扰，使接收端不可能对码元进行完全正确的识别。\n信道的频带越宽（即能通过的信号高频分量越多)，就可以用更高速率进行码元的有效传输。\n奈氏准则给出码元传输速率限制,没有对信息传输速率给出限制。\n码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须使每个码元能携带更多比特信息量,这就需要采用多元制的调制方法。\n\n2-3极限数据传输率（理想低通信道）\n例：某通信链路的带宽为2kHz，采用2个相位，每个相位具有2种振幅的调制技术，求该通信链路的最大数据传输率是。\n解：2相位 * 每相位2振幅 = 4种变化则每码元携带2bit数据W = 2000 Hz传输率 = 2 * 2000 * 2 = 8000 b/s = 8 kb/s\n3.香农定理3-1信噪比噪声存在于所有的电子设备和通信信道。噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，信噪比就很重要。\n信噪比=信号平均功率/噪声平均功率，常记为S/N，并用分贝dB作为度量单位。\n\n3-2含义在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。\n3-3极限数据传输率（带宽限且有噪声）\n若题目所给信噪比单位为dB，通过3-1中公式换算为S/N\n3-4解释\n带宽和信噪比与极限数据传输率正相关\n带宽和信噪比确定，信息传输速率就确定了\n信息传输速率低于极限速率，必有某方法可实现无差错传输\n实际速率低于极限速率\n\n4.奈氏和香农对比\n\n\n\n香农\n奈氏\n\n\n\n信道\n带宽受限，有噪声\n带宽受限，无噪声\n\n\n关注\n噪声影响问题（外）\n码间串扰问题（内）\n\n\n方案\n提高带宽，提高信噪比\n提高带宽，换编码方式（携带更多bit）\n\n\n所得两个极限速率，取其中更小的一个\n","categories":["计算机网络","物理层"],"tags":["计算机网络"]},{"title":"计算机网络-11基带和宽带信号","url":"/2022/01/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-11%E5%9F%BA%E5%B8%A6%E5%92%8C%E5%AE%BD%E5%B8%A6%E4%BF%A1%E5%8F%B7/","content":"1.信道信号的传输媒介。\n一般用来表示向某一个方向传送信息的介质。\n一条通信线路往往包含一条发送信道和一条接收信道。\n按传输信号分为：模拟、数字信道。\n按传输介质分为：有线、无线信道。\n2.传输信号2-1.基带信号来自信源的信号，直接表达了要传输的信息的信号。\n可以是模拟信号，也可以是数字信号，网络传输中只能数字信号。\n像说话声波、计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。\n将数字信号1/0直接用两种不同电压表示，送到数字信道上传输（基带传输）。\n2-2.宽带信号将基带信号进行调制后形成的频分复用模拟信号，\n再传送到模拟信道上去传输（宽带传输)。\n把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输\n（即仅在一段频率范围内能够通过信道)。\n2-3.对比应用在传输距离较近时，计算机网络采用基带传输方式\n（近距离衰减小，信号内容不易发生变化）\n在传输距离较远时，计算机网络采用宽带传输方式\n（远距离衰减大，信号变化大)\n","categories":["计算机网络","物理层"],"tags":["计算机网络"]},{"title":"计算机网络-12编码和调制","url":"/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-12%E7%BC%96%E7%A0%81%E5%92%8C%E8%B0%83%E5%88%B6/","content":"1.综述1-1.编码：数据→数字信号数字数据 →（数字发送器）→ 数字信号\n模拟数据 → （PCM编码器）→ 数字信号\n1-2.调制：数据→模拟信号数字数据 → （调制器）→ 模拟信号\n模拟数据 → （放大器调制器）→ 模拟信号\n2.数字数据→数字信号1）非归零编码NRZ2）归零编码RZ3）反向不归零编码NRZI4）曼切斯特编码（抗干扰性弱于5）5）差分曼切斯特编码6）4B/5B编码（传输效率80%）\n\n\n…归零：难以保持同步，如果连续多个相同信号可通出现一条直线。\n…斯特：传输速率只有调制速率1/2，一个信号电平两次跳变。\n3.数字数据→模拟信号例如：    调幅：0无振幅，1有振幅    调频：0频率低，1频率高    调相：0余弦，1正弦\n调幅+调相 QAM：某通信链路的波特率1200Baud，采用4个相位且每个相位有4种振幅的QAM调制技术，该链路的信息传输速率？\n4.模拟数据→数字信号音频等数据需要调整为数字信号才能被计算机处理。\n典型例子：对音频信号进行编码的脉码调制（PCM）\n步骤：抽样、量化、编码\n\n抽样对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信号。为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样。采样定理： 采样频率信号最高频率\n量化把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。\n编码把量化的结果转换为与之对应的二进制编码。\n\n\n\n采样定理解析：假设波形表达式为 频率已知则b已知，a和c需要两点才可确定因此一个波至少采样两个点，可以使每个波都可确定采样频率信号最高频率\n\n5.模拟数据→模拟信号为了实现传输的有效性，可能需要较高的频率。\n这种调制方式还可以使用频分复用技术，充分利用带宽资源。\n在电话机和本地交换机传输的信号，是采用模拟信号传输模拟数据的方式。\n模拟的声音数据是加载到模拟的载波信号中传输的。\n","categories":["计算机网络","物理层"],"tags":["计算机网络"]},{"title":"计算机网络-13数据交换(电路/报文/分组)","url":"/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-13%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2-%E7%94%B5%E8%B7%AF-%E6%8A%A5%E6%96%87-%E5%88%86%E7%BB%84/","content":"1.电路交换1-1.原理在数据传输期间，源结点与目的结点之间有一条由中间结点构成的专用物理连接线路，在数据传输结束之前，这条线路一直保持。\n\n过程：建立连接（呼叫/电路建立）&emsp;&emsp;&emsp;通信（数据传输）&emsp;&emsp;&emsp;释放连接（拆除电路）\n1-2.特点独占资源，用户始终占用端到端的固定传输带宽。\n适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况。\n1-3.优点\n传输时延小。\n数据顺序传送，无失序问题。\n实时性强，双方一旦建立物理通路，便可以实时通信，适用于交互式会话类通信。\n全双工通信，没有冲突，通信双方有不同的信道，不会争用物理信道。\n适用于模拟信号和数字信号。\n控制简单，电路的交换设备及控制较简单。\n\n1-4.缺点\n建立连接时间长。\n线路独占，即使通信线路空闲，也不能供其他用户使用，信道使用效率低。\n灵活性差，双方连接通路中的任何一点出了故障，必须重新拨号建立新连接，不适应突发性通信。\n无数据存储能力，难以平滑通信量。\n电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信。\n无法发现与纠正传输差错，难以在通信过程中进行差错控制。\n\n2.报文交换2-1.报文报文（message）是网络中交换与传输的数据单元，即站点一次性要发送的数据块。\n报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。\n2-2.原理无需在两个站点之间建立专用通路，其数据传输的单位是报文，传送过程采用存储转发方式。\n\n过程：\n\n每个节点收下整个报文后，暂存报文并检查有无错误。\n节点需要的输出电路空闲时，利用路由信息找到并传送给下一个结点地址。\n两个通信用户间的其他线路段，可传输其他用户的报文，不像电路交换那样必须占用端到端的全部信道。\n\n2-3.优点\n无需建立连接，无建立连接时延，用户可随时发送报文。\n动态分配线路，动态选择报文通过的最佳路径，可以平滑通信量。\n提高线路可靠性，某条传输路径发生故障，可重新选择另一条路径传输。\n提高线路利用率，通信双方在不同的时间一段一段地部分占有这条物理通道，多个报文可共享信道。\n提供多目标服务，一个报文可同时发往多个目的地址。\n在存储转发中容易实现代码转换和速率匹配，甚至收发双方可以不同时处于可用状态。这样就便于类型、规格和速度不同的计算机之间进行通信。\n\n2-4.缺点实时性差，不适合传送实时或交互式业务的数据。数据进入交换结点后要经历存储转发过程，从而引起转发时延。\n只适用于数字信号。\n由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。\n3.分组交换3-1.分组大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送。这种小块就称作分组（packet）。\n小数据块 + 控制信息(起止地址、编号) = 分组\n3-2.原理分组交换与报文交换的工作方式基本相同，都采用存储转发方式。\n形式上的主要差别在于，分组交换网中要限制所传输的数据单位的长度，一般选128B。\n过程：\n\n发送节点首先对从终端设备送来的数据报文进行接收、存储，而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。\n接收结点将收到的分组组装成信息或报文。\n\n3-3.优点\n无建立时延，无需为通信双方预先建立一条专用通信线路，用户可随时发送分组。\n线路利用率高，通信双方在不同的时间，一段一段地部分占有这条物理通道，多个分组可共享信道。\n简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。\n减少出错几率和重发数据量，提高可靠性，减少传输时延。\n分组短小，适用于计算机之间突发式数据通信。\n\n3-4.缺点\n尽管分组交换比报文交换的传输时延少，但仍有存储转发时延，且其结点交换机必须具有更强的处理能力。\n每个分组都要加控制信息，—定程度上降低了通信效率,增加了处理的时间。\n当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。\n\n4.数据报和虚电路分组交换包括数据报和虚电路两种方式。\n4-1.数据报方式\n\n源主机(A)将报文分成多个分组，依次发送到直接相连的结点(A)。\n结点A收到分组后，对每个分组差错检测和路由选择，不同分组的下一跳结点可能不同。\n结点C收到分组P1后，对分组P1进行差错检测，若正确则向A发送确认信息，A收到C确认后则丢弃分组P1副本。\n最终所有分组到达主机B。-\n\n4-2.虚电路方式虚电路将数据报方式和电路交换方式结合，以发挥两者优点。\n\n\n虚电路∶一条源主机到目的主机，类似于电路的路径（逻辑连接），路径上所有结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项记录了一个打开的虚电路的信息。（在数据报的方式确定一条固定的路径）\n4-3.二者对比\n\n\n\n数据报服务\n虚电路服务\n\n\n\n连接的建立\n不要\n必须有\n\n\n目的地址\n每个分组都有完整的目的地址\n仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号\n\n\n路由选择\n每个分组独立地进行路由选择和转发\n属于同一条虚电路的分组按照同一路由转发\n\n\n分组顺序\n不保证分组的有序到达\n保证分组的有序到达\n\n\n可靠性\n不保证可靠通信，可靠性由用户主机来保证\n保证分组的有序到达\n\n\n对网络故障的适应性\n出故障的结点丢失分组，其他分组路径选择发生变化，可正常传输\n所有经过故障结点的虚电路均不能正常工作\n\n\n差错处理和流量控制\n由用户主机进行流量控制，不保证数据报的可靠性\n可由分组交换网负责，也可由用户主机负责\n\n\n5.交换方式对比\n\n\n\n\n传送数据量大，且传送时间远大于呼叫时间，选择电路交换。电路交换传输时延最小。\n当端到端的通路有很多段的链路组成时,采用分组交换传送数据较为合适。\n从信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。\n\n5.总结\n电路交换\n报文交换\n分组交换\n\n2 和 3 采用存储转发地交换方式\n3 包括数据报方式和虚电路方式\n","categories":["计算机网络","物理层"],"tags":["计算机网络"]},{"title":"静态资源访问","url":"/2022/01/30/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/","content":"静态资源文件加载顺序Spring Boot 默认会挨个从META/resource → resources → static → public里找是否存在该资源。\n默认配置spring.resources.static-locations = classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/\n可以在配置文件里重写此配置。\n","categories":["Java","SpringBoot"],"tags":["SpringBoot"]},{"title":"数据预处理—NumPy","url":"/2022/05/16/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E2%80%94NumPy/","content":"1. 基础# 引入import numpy as np\n\n1.1 一维数组对象def py_sum():    # 原生方式计算A**2+B**3    a = [0, 1, 2, 3, 4]    b = [9, 8, 7, 6, 5]    c = []    for i in range(len(a)):        c.append(a[i] ** 2 + b[i] ** 3)    return cdef np_sum():    # numpy库计算A**2+B**3    a = np.array([0, 1, 2, 3, 4])    b = np.array([9, 8, 7, 6, 5])    c = a ** 2 + b ** 3    return c\n\n\n数组对象可以去掉元素间运算所需的循环，使一维向量更像单个数据。\n设置专门的数组对象，经过优化，可以提升这类应用的运算速度。\n数组对象采用相同的数据类型，有助于节省运算和存储空间。\n\n1.2 N维数组对象ndarray 是一个多维数组对象,由两部分构成：\n\n实际的数据\n描述这些数据的元数据(数据维度、数据类型等)\n\nIn [5]: a=np.array([[0,1,2,3,4],                    [9,8,7,6,5]])In [6]: aOut[6]: array([[0, 1, 2, 3, 4],       [9, 8, 7, 6, 5]])In [7]: print(a)[[0 1 2 3 4] [9 8 7 6 5]]\n\n\nnp.array()生成一个ndarray数组\nndarray在程序中的别名是：array\nnp.array()输出成目形式，元素由空格分割。\n\n2. 属性轴(axis)：保存数据的维度\n秩(rank)：轴的数量\nndarray 数组一般要求所有元素类型相同（同质），数组下标从0开始。\nIn [7]: a=np.array([[0,1,2,3,4],                    [9,8,7,6,5]])In [8]: a.ndim # 秩，即轴的数量或维度的数量Out[8]: 2In [9]: a.shape # ndarray对象的尺度,对于矩阵,n行m列Out[9]: (2, 5)In [10]: a.size # ndarray对象元素的个数，相当于.shape中n*m的值Out[10]: 10In [11]: a.dtype # darray对象的元素类型Out[11]: dtype(&#x27;int32&#x27;)In [12]: a.itemsize # ndarray对象中每个元素的大小，以字节为单位Out[12]: 4\n\n非同质情况\nIn [20]: bOut[18]: array([list([0, 1, 2, 3, 4]), list([9, 8, 7, 6])], dtype=object)In [21]: b.shapeOut[21]: (2,)In [22]: b.dtypeOut[22]: dtype(&#x27;O&#x27;) # object类型In [23]: b.itemsizeOut[23]: 8In [24]: b.sizeOut[24]: 2\n\n3. 数据类型\n\n\n类型\n说明\n\n\n\nbool\n布尔类型，True或False\n\n\nintc\n与C语言中的int类型一致，一般是int32或int64\n\n\nintp\n用于索引的整数，与C语言中ssize_t一致,int32或int64\n\n\nint8\n字节长度的整数，取值:[-128,127]\n\n\nint16\n16位长度的整数，取值:[-32768,32767]\n\n\nint32\n32位长度的整数，取值:[-2^31,2^31-1]\n\n\nint64\n64位长度的整数，取值:[-2^63,2^63-1]\n\n\nuint8\n8位无符号整数,取值:[0,255]\n\n\nuint16\n16位无符号整数,取值:[0,65535]\n\n\nuint32\n32位无符号整数,取值:[0,2^32-1]\n\n\nuint64\n64位无符号整数，取值:[0,2^64-1]\n\n\nfloat16\n16位半精度浮点数:1位符号位，5位指数，10位尾数\n\n\nfloat32\n32位半精度浮点数:1位符号位，8位指数，23位尾数\n\n\nfloat64\n64位半精度浮点数:1位符号位，11位指数，52位尾数\n\n\ncomplex64\n复数类型，实部和虚部都是32位浮点数\n\n\ncomplex128\n复数类型，实部和虚部都是64位浮点数\n\n\n\n科学计算涉及数据较多,对存储和性能都有较高要求。\n对元素类型精细定义,有助于NumPy合理使用存储空间并优化性能。\n对元素类型精细定义,有助于程序员对程序规模有合理评估。\n\n4. 数组创建4.1    从列表、元组等创建In [27]: a = np.array([0,1,2,3]) # 列表In [28]: print(a)[0 1 2 3]In [29]: a = np.array((4,5,6,7)) # 元组In [30]: print(a)[4 5 6 7]In [33]: a = np.array([(4,5,6,7),[0,1,2,3]]) #混合In [34]: print(a)[[4 5 6 7] [0 1 2 3]]\n\n4.2 用NumPy中函数创建# 生成1维数组，类似于range()In [40]: np.arange(5)Out[40]: array([0, 1, 2, 3, 4])# 参数shape表示形状，是一个元组。生成一个全1数组In [41]: np.ones((3,5))Out[41]: array([[1., 1., 1., 1., 1.],       [1., 1., 1., 1., 1.],       [1., 1., 1., 1., 1.]])# 生成全0数组In [43]: np.zeros((3,5))Out[43]: array([[0., 0., 0., 0., 0.],       [0., 0., 0., 0., 0.],       [0., 0., 0., 0., 0.]])#参数：形状，内容In [47]: np.full((2,5),6)Out[47]: array([[6, 6, 6, 6, 6],       [6, 6, 6, 6, 6]])#生成对角矩阵In [49]: np.eye(3)Out[49]: array([[1., 0., 0.],       [0., 1., 0.],       [0., 0., 1.]])\n\nones、zeros、eye默认生成浮点数的数组，可加参数指定类型，比如dtype=np.int32\nIn [52]: a = np.full((2,3),8)# 根据a的形状创建全1数组In [53]: np.ones_like(a)Out[53]: array([[1, 1, 1],       [1, 1, 1]])# 根据a的形状创建全0数组In [54]: np.zeros_like(a)Out[54]: array([[0, 0, 0],       [0, 0, 0]])# 根据a的形状创建全3数组In [55]: np.full_like(a,3)Out[55]: array([[3, 3, 3],       [3, 3, 3]])\n\n# 根据起止数据，等间距填充数据，形成数组In [56]: np.linspace(1,10,3)Out[56]: array([ 1. ,  5.5, 10. ])    #不包括结尾数据In [57]: np.linspace(1,10,3,endpoint=False)Out[57]: array([1., 4., 7.])In [72]: a = np.full((2,3),1)In [73]: b = np.full((2,3),2)# 合并，一维直接合并，多维列数得一致In [74]: np.concatenate((a,b))Out[74]: array([[1, 1, 1],       [1, 1, 1],       [2, 2, 2],       [2, 2, 2]])\n\n\n\n\n从字节流(raw bytes)中创建ndarray数组。\n从文件中读取特定格式，创建ndarray数组。\n\n5.数组变换5.1 维度变换# a初始内容In [82]: aOut[82]: array([[4, 5, 6, 7],       [0, 1, 2, 3],       [8, 9, 8, 9]])#调用flatten降维，返回新数组In [90]: a.flatten()Out[90]: array([4, 5, 6, 7, 0, 1, 2, 3, 8, 9, 8, 9])# a和原来一致In [83]: aOut[83]: array([[4, 5, 6, 7],       [0, 1, 2, 3],       [8, 9, 8, 9]])# 调用reshape，返回变换后的新数组In [84]: a.reshape(4,3)Out[84]: array([[4, 5, 6],       [7, 0, 1],       [2, 3, 8],       [9, 8, 9]])#a和原来一致，没变In [85]: aOut[85]: array([[4, 5, 6, 7],       [0, 1, 2, 3],       [8, 9, 8, 9]])# 调用resizeIn [86]: a.resize((2,6))#a变为新数组In [87]: aOut[87]: array([[4, 5, 6, 7, 0, 1],       [2, 3, 8, 9, 8, 9]])\n\n5.2 类型变换# a初始值In [94]: aOut[94]: array([[[1, 1, 1, 1],        [1, 1, 1, 1],        [1, 1, 1, 1]],       [[1, 1, 1, 1],        [1, 1, 1, 1],        [1, 1, 1, 1]]])        # 类型转换为浮点型。不加参数，会拷贝一份原数组In [95]: b=a.astype(np.float)In [96]: bOut[96]: array([[[1., 1., 1., 1.],        [1., 1., 1., 1.],        [1., 1., 1., 1.]],       [[1., 1., 1., 1.],        [1., 1., 1., 1.],        [1., 1., 1., 1.]]])# 数组转变为list列表In [97]: b.tolist()Out[97]: [[[1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0]], [[1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0]]]\n\n6. 数组操作\n索引：获取数组中特定位置元素的过程\n切片：获取数组元素子集的过程\n\n6.1 一维In [98]: a = np.array([9,8,7,6,5])In [99]: a[2] # 索引Out[99]: 7In [100]: a[1:4:2] # 切片，下标[1,4)中步长为2的元素Out[100]: array([8, 6])\n\n6.2 多维In [102]: aOut[102]: array([[[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11]],       [[12, 13, 14, 15],        [16, 17, 18, 19],        [20, 21, 22, 23]]])In [104]: a[0,2,3] # 索引。使用下标Out[104]: 11In [105]: a[-1,-2,-3] # 索引。倒数第1组，倒数第2行，倒数第3列Out[105]: 17&quot;&quot;&quot;a:b, 下标为[a,b)a:b:c, 下标为[a,b)中，步长为2的元素&quot;&quot;&quot;In [106]: a[:,1,-3] # 切片。第一维不限制，第二维下标为1，第三维倒数第3个Out[106]: array([ 5, 17])In [107]: a[:, 1:3, : ] # 切片。第一、三维不限制，第二维下标为[1,3)Out[107]: array([[[ 4,  5,  6,  7],        [ 8,  9, 10, 11]],       [[16, 17, 18, 19],        [20, 21, 22, 23]]])In [108]: a[:, :, ::2] # 切片。第一、二维不限制，第三维取步长为2Out[108]: array([[[ 0,  2],        [ 4,  6],        [ 8, 10]],       [[12, 14],        [16, 18],        [20, 22]]])\n\n7. 数组运算数组与标量之间的运算作用于数组的每一个元素\n7.1 一元函数\n\n\n函数\n说明\n\n\n\nnp.mean(x)\n所有元素的平均值\n\n\nnp.abs(x)  np.fabs(x)\n计算数组各元素的绝对值\n\n\nnp.sqrt(x)\n计算数组各元素的平方根\n\n\nnp.square(x)\n计算数组各元素的平方\n\n\nnp.log(x) np.log10(x) np.log2(x)\n计算数组各元素的自然对数、10底对数和2底对数\n\n\nnp.ceil(x) np.floor(x)\n计算数组各元素的ceiling值（向上取整）或floor值（向下取整）\n\n\nnp.rint( x)\n计算数组各元素的四舍五入值（py3中，等于最接近的整数，如果到两边距离相同，则等于偶数）\n\n\nnp.modf(x)\n将数组各元素的小数和整数部分以两个独立数组形式返回\n\n\nnp.cos(x) np.cosh(x) np.sin(x) np.sinh(x)np.tan(x) np.tanh(x)\n计算数组各元素的普通型和双曲型三角函数\n\n\nnp. exp(x)\n计算数组各元素的指数值\n\n\nnp.sign(x)\n计算数组各元素的符号值，1(+)，0，-1(-)\n\n\n7.2 二元函数\n\n\n函数\n说明\n\n\n\n+ - * / **\n两个数组各元素进行对应运算\n\n\nnp.maximum( x,y) np.fmax()  np.minimum( x,y) np.fmin()\n元素级的最大值/最小值计算\n\n\nnp.mod(x,y)\n元素级的模运算\n\n\nnp.copysign(x,y)\n将数组y中各元素值的符号赋值给数组x对应元素\n\n\n&gt; &lt; &gt;= &lt;= == !=\n算术比较，产生布尔型数组\n\n\n8. 读写文件8.1 CSV文件np.savetxt (frame, array, fmt= &#39;%.18e &#39;, delimiter=None)\n将数组内容写入文件\n\nframe：文件、字符串或产生器，可以是.gz或.bz2的压缩文件\narray：存入文件的数组\nfmt:写入文件的格式，例如∶%d %.2f %.18e\ndelimiter：分割字符串，默认是任何空格\n\nIn [144]: aOut[144]: array([[ 0,  1,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14],       [15, 16, 17, 18, 19]])In [147]: np.savetxt(&#x27;C:\\\\Users\\\\K\\\\Desktop\\\\a.csv&#x27;, a, fmt=&#x27;%d&#x27;, delimiter=&#x27;,&#x27;)&quot;&quot;&quot;文件内容：    0,1,2,3,4    5,6,7,8,9    10,11,12,13,14    15,16,17,18,19&quot;&quot;&quot;In [149]: np.savetxt(&#x27;C:\\\\Users\\\\K\\\\Desktop\\\\b.csv&#x27;, a, fmt=&#x27;%.2f&#x27;)&quot;&quot;&quot;文件内容：    0.00 1.00 2.00 3.00 4.00    5.00 6.00 7.00 8.00 9.00    10.00 11.00 12.00 13.00 14.00    15.00 16.00 17.00 18.00 19.00&quot;&quot;&quot;\n\nnp.loadtxt(frame, dtype=np.float, delimiter=None, unpack=False)\n将文件内容读入数组\n\nframe：文件、字符串或产生器，可以是.gz或.bz2的压缩文件\ndtype：数据类型，可选，默认浮点\ndelimiter：分割字符串，默认是任何空格\nunpack：如果True，读入属性将分别写入不同变量\n\n&quot;&quot;&quot;文件内容：    0,1,2,3,4    5,6,7,8,9    10,11,12,13,14    15,16,17,18,19&quot;&quot;&quot;In [151]: b = np.loadtxt(&#x27;C:\\\\Users\\\\K\\\\Desktop\\\\a.csv&#x27;, delimiter=&#x27;,&#x27;)In [152]: bOut[152]: array([[ 0.,  1.,  2.,  3.,  4.],       [ 5.,  6.,  7.,  8.,  9.],       [10., 11., 12., 13., 14.],       [15., 16., 17., 18., 19.]])In [153]: b = np.loadtxt(&#x27;C:\\\\Users\\\\K\\\\Desktop\\\\a.csv&#x27;, delimiter=&#x27;,&#x27;, dtype=np.int)In [154]: bOut[154]: array([[ 0,  1,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14],       [15, 16, 17, 18, 19]])\n\ncsv只能有效存储一维和二维数组\nnp.savetxt()和np.loadtxt()只能有效存取一维和二维数组\n8.1 任意维度数据array_name.tofile( frame, sep=&#39;&#39;, format=&#39;%s &#39;)\n\na：本库生成的数组\nframe：文件、字符串\nsep：数据分割字符串，如果是空串，写入文件为二进制\nformat：写入数据的格式\n\n存储时，将多维数据转化为一维\nIn [155]: aOut[155]: array([[ 0,  1,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14],       [15, 16, 17, 18, 19]])In [157]: a.tofile(&quot;C:\\\\Users\\\\K\\\\Desktop\\\\a.dat&quot;, sep=&#x27;,&#x27;, format=&#x27;%d&#x27;)# 文件中：0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19    In [158]: a.tofile(&quot;C:\\\\Users\\\\K\\\\Desktop\\\\b.dat&quot;, format=&#x27;%d&#x27;)# 文件中乱码（二进制文件）\n\nnp.fromfile( frame, dtype=float, count=-1, sep=&#39; &#39;)\n\nframe：文件、字符串\ndtype：读取的数据奕型\ncount：读入元素个数，-1表示读入整个文件\nsep：数据分割字符串，如果是空串，写入文件为二进制\n\n读取结果为一维，可通过reshape转化为多维\n# 两个文件中数据，见上个代码块In [160]: np.fromfile(&quot;C:\\\\Users\\\\K\\\\Desktop\\\\a.dat&quot;, dtype=np.float, count=-1, sep=&#x27;,&#x27;).reshape(4,5)Out[160]: array([[ 0.,  1.,  2.,  3.,  4.],       [ 5.,  6.,  7.,  8.,  9.],       [10., 11., 12., 13., 14.],       [15., 16., 17., 18., 19.]])In [162]: np.fromfile(&quot;C:\\\\Users\\\\K\\\\Desktop\\\\b.dat&quot;, dtype=np.int, count=-1).reshape(4,5)Out[162]: array([[ 0,  1,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14],       [15, 16, 17, 18, 19]])\n\n\n该方法需要读取时知道存入文件时数组的维度和元素类型\na.tofile()和np .fromFile()需要配合使用\n可以通过元数据文件来存储额外信息\n\n8.3 Numpy 便捷存取np.save( fname, array)或np.savez(fname，array)\n\nfname：文件名，以.npy为扩展名，压缩扩展名为.npz\narray：数组变量\n\nnp.load( fname)\n\nfname：文件名，以.npy为扩展名，压缩扩展名为.npz\n\nIn [163]: aOut[163]: array([[ 0,  1,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14],       [15, 16, 17, 18, 19]])In [164]: np.save(&quot;C:\\\\Users\\\\K\\\\Desktop\\\\a.npy&quot;, a)In [165]: np.load(&quot;C:\\\\Users\\\\K\\\\Desktop\\\\a.npy&quot;)Out[165]: array([[ 0,  1,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14],       [15, 16, 17, 18, 19]])\n\n9. 随机数\n\n\n函数\n说明\n\n\n\nrand(d0,d1, . . , dn)\nd0-dn为形状，内容为[0,1)浮点数，均匀分布\n\n\nrandn(d0,d1, . . ,dn)\nd0-dn为形状，内容为标准正态分布\n\n\nrandint(low, high, shape)\nshape为元组表形状，范围是[low,high)\n\n\nseed(s)\n随机数种子，s是给定的种子值，相同种子形成相同随机数\n\n\nshuffle(a)\n根据数组a的第1轴（最外维）进行随排列，改变数组x\n\n\npermutation(a)\n根据数组a的第1轴产生一个新的乱序数组，不改变数组x\n\n\nchoice(a, size, replace, p])\n从一维数组a中以概率p抽取元素，形成size形状新数组，replace表示是否可以重用元素，默认为False\n\n\nuniform( low, high, size)\n产生具有均匀分布的数组, low起始值, high结束值, size形状\n\n\nnormal( loc, scale, size)\n产生具有正态分布的数组,loc均值,scale标准差,size形状\n\n\npoisson(lam,size)\n产生具有泊松分布的数组,lam随机事件发生率,size形状\n\n\nIn [169]: aOut[169]: array([[[148, 156, 101, 131],        [126, 108, 160, 166],        [152, 111, 130, 129]],       [[169, 151, 125, 106],        [129, 121, 142, 143],        [188, 117, 172, 160]],       [[104, 194, 185, 182],        [183, 182, 114, 149],        [102, 148, 146, 152]]])In [170]: np.random.permutation(a) # shuffle(a)作用一样，但改变原数组Out[170]: array([[[169, 151, 125, 106],        [129, 121, 142, 143],        [188, 117, 172, 160]],       [[148, 156, 101, 131],        [126, 108, 160, 166],        [152, 111, 130, 129]],       [[104, 194, 185, 182],        [183, 182, 114, 149],        [102, 148, 146, 152]]])&quot;&quot;&quot;m为一维数组(3,2)为目标数组形状replace=False，默认值，表示不重复使用m中的数据p表示每个数据被取概率&quot;&quot;&quot;np.rendom.choice(m, (3,2), replace=False, p=m/np.sum(b))\n\n10. 统计In [173]: aOut[173]: array([[[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11]],       [[12, 13, 14, 15],        [16, 17, 18, 19],        [20, 21, 22, 23]],       [[24, 25, 26, 27],        [28, 29, 30, 31],        [32, 33, 34, 35]]])&quot;&quot;&quot;轴的概念：注意：3维数组，想象成正方体更好理解第0轴，第1轴，第2轴……对第0轴操作：按第一个维度分开，依次操作\t按第一个维度，可分为3组，组间求和，结果为：    \t[36, 39, 42, 45],        [48, 51, 54, 57],        [60, 63, 66, 69]对第1轴操作：按第二个维度分开，依次操作\t按第二个维度，每组可分为3行，行间求和，结果为：\t\t[12, 15, 18, 21],        [48, 51, 54, 57],        [84, 87, 90, 93]\t15：第一组，第二列之和（行之间求和）对第2轴操作：按第三个维度分开，依次操作\t按第三个维度，每组可分为3列，列间求和，结果为：\t\t[  6,  22,  38],        [ 54,  70,  86],        [102, 118, 134]\t22：第一组，第二行之和（列之间求和）&quot;&quot;&quot;\n\n\n\n\n函数\n说明\n\n\n\nsum(a, axis=None)\n根据给定轴axis计算数组a相关元素之和，axis整数或元组\n\n\nmean(a,axis=None)\n根据给定轴axis计算数组a相关元素的期望，axis整数或元组\n\n\naverage(a,axis=None,weights=None)\n根据给定轴axis计算数组a相关元素的加权平均值\n\n\nstd(a,axis=None)\n根据给定轴axis计算数组a相关元素的标准差\n\n\nvar(a, axis=None)\n根据给定轴axis计算数组a相关元素的方差\n\n\nmin(a) max( a)\n计算数组a中元素的最小值、最大值\n\n\nargmin(a) argmax( a)\n计算数组a中元素最小值、最大值的降一维后下标\n\n\nunravel_index(index,shape)\n根据shape将一维下标index转换成多维下标\n\n\nptp(a)\n计算数组a中元素最大值与最小值的差\n\n\nmedian( a)\n计算数组a中元素的中位数（中值）\n\n\nIn [178]: aOut[178]: array([[ 0,  1,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14]])In [179]: np.average(a)Out[179]: 7.0In [180]: np.average(a, axis=0)Out[180]: array([5., 6., 7., 8., 9.])In [181]: np.average(a, axis=0, weights=[10,5,1])Out[181]: array([2.1875, 3.1875, 4.1875, 5.1875, 6.1875])# 4.1875 = (2*10+7*5+12*1)/(10+5+1)In [185]: aOut[185]: array([[ 0, 20,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14]])In [186]: np.max(a) # 最大值Out[186]: 20In [187]: np.argmax(a) # 化为1维后，最大值下标Out[187]: 1In [188]: np.unravel_index(np.argmax(a), a.shape) # 一维下标转化为多维下标Out[188]: (0, 1)\n\n11. 梯度\n\n\n函数\n说明\n\n\n\nnp.gradient(a)\n计算数组a中元素的梯度，当a为多维时，返回每个维度梯度\n\n\nIn [190]: aOut[190]: array([[ 0, 20,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14]])In [191]: np.gradient(a)Out[191]: [array([[  5. , -14. ,   5. ,   5. ,   5. ],        [  5. ,  -4.5,   5. ,   5. ,   5. ],        [  5. ,   5. ,   5. ,   5. ,   5. ]]), array([[20. ,  1. , -8.5,  1. ,  1. ],        [ 1. ,  1. ,  1. ,  1. ,  1. ],        [ 1. ,  1. ,  1. ,  1. ,  1. ]])]&quot;&quot;&quot;第一个array，行之间（列方向）的梯度\t-4.5 = (11 - 20) / 2 非边界：下一个值与上一个值的差，除以二\t-14. = (6 - 20) / 1 边界：下一个值与当前值的差，除以1第一个array，列之间（行方向）的梯度&quot;&quot;&quot;\n\n","categories":["数据预处理"],"tags":["数据预处理","NumPy"]},{"title":"数据预处理—Pandas","url":"/2022/06/25/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E2%80%94Pandas/","content":"1. 介绍Pandas是Python第三方库，提供高性能易用数据类型和分析工具。\nIn [192]: import pandas as pdIn [193]: pd.__version__\n\n核心：\n​    两个数据类型Series,DataFrame\n\n基于上述数据类型的各类操作\n基本操作、运算操作、特征类操作、关联类操作\n\n对比：\n\n\n\nNumPy\nPandas\n\n\n\n基础数据类型\n扩展数据类型\n\n\n关注数据的结构表达\n关注数据的应用表达\n\n\n维度和数据间关系\n数据与索引间关系\n\n\n2. Series类型series类型由一组数据及与之相关的数据索引组成\n2.1 索引添加参数index=[ , , , ]自定义索引，不添加自动生成从0开始的索引。\nindex=[ , , , ]可直接简写为[ , , , ]\n# 自动索引In [195]: pd.Series([9,8,7,6])Out[195]: 0    9 # 索引 数据1    82    73    6dtype: int64 # NumPy中的数据类型# 自定义索引（“index=”可省略）In [197]: pd.Series([9,8,7,6], index=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])Out[197]: a    9b    8c    7d    6dtype: int64\n\n2.2 创建可以由如下类型创建：\n\npython列表（见2.1）\n标量值\npython字典\nndarray\n其他函数（range等）\n\n标量值：\n# 不指定索引相当于一个值的列表In [201]: pd.Series(25, [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])Out[201]: a    25b    25c    25d    25dtype: int64\n\n字典：\nIn [203]: pd.Series(&#123;&#x27;a&#x27;:9, &#x27;b&#x27;:8, &#x27;c&#x27;:7, &#x27;d&#x27;:6&#125;)Out[203]: a    9b    8c    7d    6dtype: int64# 通过index参数，从字典中挑选In [204]: pd.Series(&#123;&#x27;a&#x27;:9, &#x27;b&#x27;:8, &#x27;c&#x27;:7, &#x27;d&#x27;:6&#125;, [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;])Out[204]: a    9.0c    7.0e    NaNdtype: float64\n\nndarray：\n#内容01234，索引98765，index = 可省略In [205]: pd.Series(np.arange(5), index = np.arange(9,4,-1))Out[205]: 9    08    17    26    35    4dtype: int32\n\n2.3 基本操作\nseries类型包括index和values两部分\nseries类型的操作类似ndarray类型\nSeries类型的操作类似Python字典类型\n\n获得索引或内容In [219]: aOut[219]: a    9.0c    7.0e    NaNdtype: float64In [220]: a.indexOut[220]: Index([&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;], dtype=&#x27;object&#x27;)In [221]: a.valuesOut[221]: array([ 9.,  7., nan])\n\n通过索引取值​    自定义索引与自动索引并存，但不能混合使用\nIn [222]: a[&#x27;c&#x27;] # 自定义索引Out[222]: 7.0In [223]: a[1] # 自动索引Out[223]: 7.0In [224]: a[[&#x27;a&#x27;, &#x27;c&#x27;]] # 自定义索引取多值Out[224]: a    9.0c    7.0dtype: float64In [225]: a[[0, 1]] # 自动索引取多值Out[225]: a    9.0c    7.0dtype: float64In [226]: a[[&#x27;a&#x27;, 1]] # 混合使用 错误❌\n\n类似ndarray的操作\n索引方法相同，采用[]\nNumPy中运算和操作可用于series类型\n可以通过自定义索引的列表进行切片\n可以通过自动索引进行切片，如果存在自定义索引，则一同被切片\n\nIn [236]: aOut[236]: a    9b    8c    7d    6e    5dtype: int64In [238]: a[1] # 索引Out[238]: 8In [239]: a[1:4:2] # 切片-[1,4)中步长为1Out[239]: b    8d    6dtype: int64    In [247]: a[a &gt; a.median()] # 切片-大于中位数的部分Out[247]: a    9b    8dtype: int64In [249]: np.exp(a) # numpy中的操作Out[249]: a    8103.083928b    2980.957987c    1096.633158d     403.428793e     148.413159dtype: float64\n\n类似字典的操作\n通过自定义索引访问\n保留字in操作\n使用.get()方法\n\nIn [250]: aOut[250]: a    9b    8c    7d    6e    5dtype: int64In [251]: a[&#x27;b&#x27;] # 索引Out[251]: 8In [252]: &#x27;b&#x27; in a # 索引是否存在Out[252]: TrueIn [253]: 8 in aOut[253]: FalseIn [254]: a.get(&#x27;b&#x27;, 100) # 索引方式2Out[254]: 8In [255]: a.get(&#x27;t&#x27;, 100)Out[255]: 100    In [256]: a[&#x27;f&#x27;] = 4 # 添加   \n\n对齐操作a和b操作结果：\n\n索引维a和b并集\n内容为a和b操作结果\n与nan操作，结果为nan\n\nIn [257]: aOut[257]: a    9b    8c    7d    6e    5dtype: int64In [258]: bOut[258]: d    6e    5f    4dtype: int64In [259]: a + bOut[259]: a     NaNb     NaNc     NaNd    12.0e    10.0f     NaNdtype: float64\n\nname属性\na.name\na.index.name\n\nIn [266]: a.name = &#x27;Series对象a&#x27;In [267]: a.index.name = &#x27;索引&#x27;    In [269]: aOut[269]: 索引a    9b    8c    7d    6e    5Name: Series对象a, dtype: int64\n\n修改series对象可以随时修改并即刻生效\nIn [272]: aOut[272]: 索引a    9b    8c    7d    6e    5Name: Series对象a, dtype: int64In [273]: a.name = &#x27;myname&#x27; # 对象名In [274]: a.index.name = &#x27;ind&#x27; # 索引列名    In [277]: a[&#x27;a&#x27;, &#x27;b&#x27;] = 10 # 通过自定义索引修改In [278]: a[2] = 30 # 通过自动索引修改In [280]: a[&#x27;f&#x27;] = 20 # 添加一条In [282]: aOut[282]: inda    10b    10c    30d     6e     5f    20Name: myname, dtype: int64\n\n3. DataFrame3.1 简洁\nDataFrame是一个表格型的数据类型，每列值类型可以不同\nDataFrame既有行索引、也有列索引\nDataFrame常用于表达二维数据，但可以表达多维数据\n\nDataFrame类型由共用相同索引的一组列组成\n​        index_0 → data_a  data_1        data_w\n​        index_1 → data_b  data_2 …… data_x\n​        index_2 → data_c  data_3        data_y\n​        index_3 → data_d  data_4        data_z\n​    index_0 index_1 … 方向：index，axis=0\n​    index_0 data_a … 方向：column，axis=1\n3.2 创建DataFrame类型可以由如下类型创建：\n\n二维ndarray对象\n由一维ndarray、列表、字典、元组或series构成的字典\nseries类型\n其他的DataFrame类型\n\n# 二维ndarray对象# 自动索引In [284]: pd.DataFrame(np.arange(12).reshape(3,4))Out[284]:    0  1   2   30  0  1   2   31  4  5   6   72  8  9  10  11# 自定义索引In [312]: pd.DataFrame(np.arange(4).reshape(2,2),                       index=[&#x27;a&#x27;,&#x27;b&#x27;],                       columns=[&#x27;c&#x27;,&#x27;d&#x27;])Out[312]:    c  da  0  1b  2  3# series字典，自定义索引# 字典关键字为列索引，series字典索引为行索引In [287]: dt = &#123;    &#x27;one&#x27;:pd.Series([1,2,3],index=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]),\t&#x27;two&#x27;:pd.Series([9,8,7,6],index[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])&#125;# 有相同行号，后面的覆盖前面的In [288]: pd.DataFrame(dt)Out[288]:    one  twoa  1.0    9b  2.0    8c  3.0    7d  NaN    6# 列表字典In [289]: d = &#123;&#x27;one&#x27;:[1,2,3], &#x27;two&#x27;:[9,8,7]&#125;# 自动行索引In [290]: pd.DataFrame(d)Out[290]:    one  two0    1    91    2    82    3    7# 自定义行索引In [292]: pd.DataFrame(d,index=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;])Out[292]:    one  twoa    1    9b    2    8c    3    7\n\n练习：\n\n\n\n城市\n环比\n同比\n定基\n\n\n\n北京\n101.5\n120.7\n121.4\n\n\n上海\n101.2\n127.3\n127.8\n\n\n广州\n101.3\n119.4\n120.0\n\n\n深圳\n102.0\n140.9\n145.5\n\n\n沈阳\n100.1\n101.4\n101.6\n\n\nIn [293]: d = &#123;    &#x27;城市&#x27;:[&#x27;北京&#x27;,&#x27;上海&#x27;,&#x27;广州&#x27;,&#x27;深圳&#x27;,&#x27;沈阳&#x27;],     &#x27;环比&#x27;:[101.5,101.2,101.3,102.0,100.1],    &#x27;同比&#x27;:[120.7,127.3,119.4,140.9,101.4],    &#x27;定基&#x27;:[121.4,127.8,120.0,145.5,101.6]&#125;In [294]: data = pd.DataFrame(d,index=[&#x27;c1&#x27;,&#x27;c2&#x27;,&#x27;c3&#x27;,&#x27;c4&#x27;,&#x27;c5&#x27;])In [295]: dataOut[295]:     城市     环比     同比     定基c1  北京  101.5  120.7  121.4c2  上海  101.2  127.3  127.8c3  广州  101.3  119.4  120.0c4  深圳  102.0  140.9  145.5c5  沈阳  100.1  101.4  101.6\n\n3.3 查询以上面城市表为例\n查询行名、列名、数据In [296]: data.indexOut[296]: Index([&#x27;c1&#x27;, &#x27;c2&#x27;, &#x27;c3&#x27;, &#x27;c4&#x27;, &#x27;c5&#x27;], dtype=&#x27;object&#x27;)In [297]: data.columnsOut[297]: Index([&#x27;城市&#x27;, &#x27;环比&#x27;, &#x27;同比&#x27;, &#x27;定基&#x27;], dtype=&#x27;object&#x27;)    In [299]: data.valuesOut[299]: array([[&#x27;北京&#x27;, 101.5, 120.7, 121.4],       [&#x27;上海&#x27;, 101.2, 127.3, 127.8],       [&#x27;广州&#x27;, 101.3, 119.4, 120.0],       [&#x27;深圳&#x27;, 102.0, 140.9, 145.5],       [&#x27;沈阳&#x27;, 100.1, 101.4, 101.6]], dtype=object)\n\n查询某列# []不带列号In [305]: data[&#x27;城市&#x27;]Out[305]: c1    北京c2    上海c3    广州c4    深圳c5    沈阳Name: 城市, dtype: object# [[]]带列号In [306]: data[[&#x27;城市&#x27;]]Out[306]:     城市c1  北京c2  上海c3  广州c4  深圳c5  沈阳In [307]: data[[&#x27;同比&#x27;, &#x27;城市&#x27;]]Out[307]:        同比  城市c1  120.7  北京c2  127.3  上海c3  119.4  广州c4  140.9  深圳c5  101.4  沈阳\n\n查询某行# []不带行号，竖放In [315]: data.loc[&#x27;c1&#x27;]Out[315]: 城市       北京环比    101.5同比    120.7定基    121.4Name: c1, dtype: object# [[]]带行号In [317]: data.loc[[&#x27;c1&#x27;]]Out[317]:     城市     环比     同比     定基c1  北京  101.5  120.7  121.4In [316]: data.loc[[&#x27;c1&#x27;,&#x27;c2&#x27;]]Out[316]:     城市     环比     同比     定基c1  北京  101.5  120.7  121.4c2  上海  101.2  127.3  127.8\n\n查询某点In [324]: data.at[&#x27;c2&#x27;, &#x27;环比&#x27;]Out[324]: 101.2\n\n3.4 索引操作如何改变series和DataFrame对象?\n\n增加或重排：reindex 重新索引 + 索引类型操作\n删除：drop 删除\n\nIndex类型操作In [338]: data.indexOut[338]: Index([&#x27;c1&#x27;, &#x27;c2&#x27;, &#x27;c3&#x27;, &#x27;c4&#x27;, &#x27;c5&#x27;], dtype=&#x27;object&#x27;)In [339]: data.columnsOut[339]: Index([&#x27;城市&#x27;, &#x27;环比&#x27;, &#x27;同比&#x27;, &#x27;定基&#x27;], dtype=&#x27;object&#x27;)\n\nindex和columns都是Index类型。\n常用方法：\n\n\n\n方法\n介绍\n\n\n\n.append(idx)\n连接另一个Index对象，产生新的Index对象\n\n\n.diff(idx)\n计算差集，产生新的Index对象\n\n\n.intersection(idx)\n计算交集\n\n\n.union(idx)\n计算并集\n\n\n.delete(loc)\n删除loc位置处的元素\n\n\n.insert( loc,e)\n在loc位置增加一个元素e\n\n\n调用上述方法后生成新的索引，然后使用reindex方法修改DataFrame\n重新索引.reindex()能够改变或重排series和DataFrame索引\n.reindex(index=None, columns=None, ...)的参数：\n\n\n\n参数\n说明\n\n\n\nindex,columns\n新的行列自定义索引\n\n\nfill_value\n重新索引中，用于填充缺失位置的值\n\n\nmethod\n填充方法，ffill当前值向前填充，bfill向后填充\n\n\nlimit\n最大填充量\n\n\ncopy\n默认True ，生成新的对象，False时，新旧相等不复制\n\n\n#原始数据In [327]: dataOut[327]:     城市     环比     同比     定基c1  北京  101.5  120.7  121.4c2  上海  101.2  127.3  127.8c3  广州  101.3  119.4  120.0c4  深圳  102.0  140.9  145.5c5  沈阳  100.1  101.4  101.6#重新指定index排序In [328]: data.reindex(index=[&#x27;c5&#x27;,&#x27;c4&#x27;,&#x27;c3&#x27;,&#x27;c2&#x27;,&#x27;c1&#x27;])Out[328]:     城市     环比     同比     定基c5  沈阳  100.1  101.4  101.6c4  深圳  102.0  140.9  145.5c3  广州  101.3  119.4  120.0c2  上海  101.2  127.3  127.8c1  北京  101.5  120.7  121.4#重新指定columns排序In [329]: data.reindex(columns=[&#x27;城市&#x27;,&#x27;同比&#x27;,&#x27;环比&#x27;,&#x27;定基&#x27;])Out[329]:     城市     同比     环比     定基c1  北京  120.7  101.5  121.4c2  上海  127.3  101.2  127.8c3  广州  119.4  101.3  120.0c4  深圳  140.9  102.0  145.5c5  沈阳  101.4  100.1  101.6# 生成新的columns，增加一列In [333]: newcol = data.columns.insert(4,&#x27;新增&#x27;)# 使用新columns，新位置用200填充In [334]: data.reindex(columns=newcol, fill_value=200)Out[334]:     城市     环比     同比     定基   新增c1  北京  101.5  120.7  121.4  200c2  上海  101.2  127.3  127.8  200c3  广州  101.3  119.4  120.0  200c4  深圳  102.0  140.9  145.5  200c5  沈阳  100.1  101.4  101.6  200# 添加新行同上\n\n删除某行/列.drop()能够删除series和DataFrame指定行或列索引\nIn [364]: dataOut[364]:     城市     环比     同比     定基c1  北京  101.5  120.7  121.4c2  上海  101.2  127.3  127.8c3  广州  101.3  119.4  120.0c4  深圳  102.0  140.9  145.5c5  沈阳  100.1  101.4  101.6In [365]: data.drop(&#x27;c3&#x27;)Out[365]:     城市     环比     同比     定基c1  北京  101.5  120.7  121.4c2  上海  101.2  127.3  127.8c4  深圳  102.0  140.9  145.5c5  沈阳  100.1  101.4  101.6In [368]: data.drop(&#x27;定基&#x27;,axis=1)Out[368]:     城市     环比     同比c1  北京  101.5  120.7c2  上海  101.2  127.3c3  广州  101.3  119.4c4  深圳  102.0  140.9c5  沈阳  100.1  101.4\n\n4. 运算4.1 算数运算\n算术运算根据行列索引，补齐后运算\n运算默认产生浮点数\n补齐时缺项默认填充NaN(空值)\n二维和一维、一维和零维间为广播运算\n采用+- */符号进行的二元运算产生新的对象\n\n# 测试数据In [374]: aOut[374]:    0  1   2   30  0  1   2   31  4  5   6   72  8  9  10  11In [375]: bOut[375]:     0   1   2   3   40   0   1   2   3   41   5   6   7   8   92  10  11  12  13  143  15  16  17  18  19In [395]: cOut[395]:    0  1  2  30  3  3  3  31  3  3  3  32  3  3  3  3\n\n直接运算In [376]: a + bOut[376]:       0     1     2     3   40   0.0   2.0   4.0   6.0 NaN1   9.0  11.0  13.0  15.0 NaN2  18.0  20.0  22.0  24.0 NaN3   NaN   NaN   NaN   NaN NaNIn [377]: a * bOut[377]:       0     1      2      3   40   0.0   1.0    4.0    9.0 NaN1  20.0  30.0   42.0   56.0 NaN2  80.0  99.0  120.0  143.0 NaN3   NaN   NaN    NaN    NaN NaN\n\n使用方法运算\n.add(d, **argws)\n.sub( d, **argws)\n.mul(d，**argws)\n.div(d，**argws)\n\nIn [384]: b.add(a)Out[384]:       0     1     2     3   40   0.0   2.0   4.0   6.0 NaN1   9.0  11.0  13.0  15.0 NaN2  18.0  20.0  22.0  24.0 NaN3   NaN   NaN   NaN   NaN NaN# 使用 fill_value 替换 NAN 参加运算In [385]: b.add(a, fill_value=100)Out[385]:        0      1      2      3      40    0.0    2.0    4.0    6.0  104.01    9.0   11.0   13.0   15.0  109.02   18.0   20.0   22.0   24.0  114.03  115.0  116.0  117.0  118.0  119.0\n\n4.2 比较运算直接运算同大小，索引相同，才可以\n符号：==、!=、&lt;、&gt;、&lt;=、&gt;=\nIn [413]: a &gt;= cOut[413]:        0      1      2     30  False  False  False  True1   True   True   True  True2   True   True   True  True\n\n使用方法运算大小和索引可以不同，索引会对应起来，缺失位用NAN填充\n\n\n\n方法\n全称\n用途\n\n\n\neq\nequal to\n==\n\n\nne\nnot equal to\n!=\n\n\nlt\nless than\n&lt;\n\n\ngt\ngreater than\n&gt;\n\n\nle\nless than or equal to\n&lt;=\n\n\nge\ngreater than or equal to\n&gt;=\n\n\nIn [417]: a.eq(b)Out[417]:        0      1      2      3      40   True   True   True   True  False1  False  False  False  False  False2  False  False  False  False  False3  False  False  False  False  False\n\n4.3 不同维度的运算# 以广播的方式进行# 0维In [421]: aOut[421]: 3# 1维In [422]: bOut[422]: a    5b    5c    5d    5dtype: int64# 2维In [423]: cOut[423]:    a  b   c   d0  0  1   2   31  4  5   6   72  8  9  10  11\n\n注：\n\n方法运算时，必须 ”高维.方法(低维)“\n直接运算，高低维位置随意\n\n一维VS多维一维与二维：\nIn [431]: a + bOut[431]: a    8b    8c    8d    8dtype: int64    In [432]: a &gt; bOut[432]: a    Falseb    Falsec    Falsed    Falsedtype: bool\n\n一维与三维类似\n二维VS三维# (c每一行与b比较)In [448]: c &gt; bOut[448]:        a      b      c      d0  False  False  False  False 1  False  False   True   True2   True   True   True   TrueIn [450]: c.gt(b)Out[450]:        a      b      c      d0  False  False  False  False1  False  False   True   True2   True   True   True   True\n\n5. 排序5.1 按轴排序.sort_index(axis=0,ascending=True)方法在指定轴上根据索引进行排序，默认升序\nIn [452]: aOut[452]:     0   1   2   3   4c   0   1   2   3   4a   5   6   7   8   9d  10  11  12  13  14b  15  16  17  18  19# 0轴升序（默认）In [455]: b = a.sort_index()In [456]: bOut[456]:     0   1   2   3   4a   5   6   7   8   9b  15  16  17  18  19c   0   1   2   3   4d  10  11  12  13  14# 1轴降序In [457]: b = b.sort_index(axis=1, ascending=False)In [458]: bOut[458]:     4   3   2   1   0a   9   8   7   6   5b  19  18  17  16  15c   4   3   2   1   0d  14  13  12  11  10\n\n5.2 按值排序.sort_values()方法在指定轴上根据数值进行排序，默认升序\n\nSeries.sort_values(axis=0, ascending=True)\nDataFrame.sort_values(by, axis=0, ascending=True)\n\n​        by：axis上第by行\\列\nIn [460]: bOut[460]:     4   3   2   1   0a   9   8   7   6   5b  19  18  17  16  15c   4   3   2   1   0d  14  13  12  11  10# 0轴方向（默认）、索引为2的列、降序In [461]: b.sort_values(2, ascending=False)Out[461]:     4   3   2   1   0b  19  18  17  16  15d  14  13  12  11  10a   9   8   7   6   5c   4   3   2   1   0# 1轴方向、索引为a的行、升序（默认）In [465]: b.sort_values(&#x27;a&#x27;, axis=1)Out[465]:     0   1   2   3   4a   5   6   7   8   9b  15  16  17  18  19c   0   1   2   3   4d  10  11  12  13  14\n\n若其中有NaN，排序时统一放到末尾。\n6. 统计分析6.1 基本统计分析\n\n\n方法\n参数\n说明\n\n\n\n.sum()\naxis=0（默认）\n计算数据的总和\n\n\n.count()\naxis=0\n非NaN值的数量\n\n\n.mean( )\naxis=0\n算术平均值\n\n\n.median()\naxis=0\n算术中位数\n\n\n.var()\naxis=0\n方差\n\n\n.std()\naxis=0\n标准差\n\n\n.min()\naxis=0\n最小值\n\n\n.max()\naxis=0\n最大值\n\n\n.argmin()\n无\n最大值所在位置的索引\n\n\n.argmax()\n无\n最小值所在位置的索引\n\n\n.idxmin()\naxis=0\n最大值所在位置的索引\n\n\n.idxmax()\naxis=0\n最小值所在位置的索引\n\n\n.describe()\n无\n针对0轴（各列）的统计汇总\n\n\n注：\n\nargmin和argmax仅用于Series，其余Series和DataFrame都行\nargmin和argmax用于Series是输出自动索引\nidxmin和idxmax用于Series是输出自动索引\ndescribe结果是DataFrame，可用DataFrame的性质和方法\n\nIn [507]: cOut[507]:    a  b   c   d0  0  1   2   31  4  5   6   72  8  9  10  11In [508]: c.sum()Out[508]: a    12b    15c    18d    21dtype: int64In [509]: c.sum(axis=1)Out[509]: 0     61    222    38dtype: int64In [527]: c.describe()Out[527]:          a    b     c     dcount  3.0  3.0   3.0   3.0mean   4.0  5.0   6.0   7.0std    4.0  4.0   4.0   4.0min    0.0  1.0   2.0   3.025%    2.0  3.0   4.0   5.050%    4.0  5.0   6.0   7.075%    6.0  7.0   8.0   9.0max    8.0  9.0  10.0  11.0In [528]: c.describe().loc[[&#x27;min&#x27;]]Out[528]:        a    b    c    dmin  0.0  1.0  2.0  3.0In [529]: c.describe()[[&#x27;c&#x27;]]Out[529]:           ccount   3.0mean    6.0std     4.0min     2.025%     4.050%     6.075%     8.0max    10.0\n\n6.1 累计统计分析\n\n\n方法\n说明\n\n\n\n.cumsum()\n依次给出前1、2、…、n个数的和\n\n\n.cumprod()\n依次给出前1、2、…、n个数的积\n\n\n.cummax()\n依次给出前1、2、…、n个数的最大值\n\n\n.cummin()\n依次给出前1、2、…、n个数的最小值\n\n\n注：默认0轴方向，可加参数 axis=1\nIn [536]: cOut[536]:    a  b   c   d0  0  1   2   31  4  5   6   72  8  9  10  11In [537]: c.cumprod()Out[537]:    a   b    c    d0  0   1    2    31  0   5   12   212  0  45  120  231In [538]: c.cumprod(axis=1)Out[538]:    a   b    c     d0  0   0    0     01  4  20  120   8402  8  72  720  7920\n\n\n\n\n方法\n说明\n\n\n\n.rolling(w).sum( )\n依次计算相邻w个元素的和\n\n\n.rolling(w).mean()\n依次计算相邻w个元素的算术平均值\n\n\n.rolling(w).var()\n依次计算相邻w个元素的方差\n\n\n.rolling(w).std()\n依次计算相邻w个元素的标准差\n\n\n.rolling(w).min( )\n依次计算相邻w个元素的最小值\n\n\n.rolling(w).max()\n依次计算相邻w个元素的最大值\n\n\n注：\n\n默认0轴方向，rolling中可加参数 axis=1\nw个元素包括当前元素和前面w-1个，不足则为NaN\n\nIn [539]: cOut[539]:    a  b   c   d0  0  1   2   31  4  5   6   72  8  9  10  11In [541]: c.rolling(3).sum()Out[541]:       a     b     c     d0   NaN   NaN   NaN   NaN1   NaN   NaN   NaN   NaN2  12.0  15.0  18.0  21.0In [542]: c.rolling(3,axis=1).sum()Out[542]:     a   b     c     d0 NaN NaN   3.0   6.01 NaN NaN  15.0  18.02 NaN NaN  27.0  30.0\n\n7. 相关性分析7.1 协方差\n协方差&gt;0，X和Y正相关\n协方差&lt;0，X和Y负相关\n协方差=0，X和Y独立无关\n\n.cov()用于计算协方差矩阵\n7.2 Pearson相关系数r为Pearson相关系数，取值范围[-1,+1]\n|r|范围：\n\n0.8-1.0 极强相关\n0.6-0.8 强相关\n0.4-0.6 中等程度相关\n0.2-0.4 弱相关\n0.0-0.2 极弱相关或无相关\n\n.corr()用于计算相关系数矩阵（Pearson、Spearman、Kendall等系数）\n示例：\nIn [556]: aOut[556]: 2008     3.042009    22.932010    12.752011    22.602012    12.33dtype: float64In [557]: bOut[557]: 2008     8.182009    18.382010     9.132011     7.822012     6.96dtype: float64In [558]: a.cov(b)Out[558]: 20.46345In [559]: a.corr(b)Out[559]: 0.5249598283887876\n\n8. 文件读写Pandas CSV 文件 | 菜鸟教程 (runoob.com)\nPandas JSON | 菜鸟教程 (runoob.com)\n9. 数据清洗空值、错值、重复值\nPandas 数据清洗 | 菜鸟教程 (runoob.com)\n","categories":["数据预处理"],"tags":["数据预处理","Pandas"]}]